#!/usr/bin/env python3

import shutil
import subprocess
import sys
import numpy as np
import json
import copy
import time
import os
import socket
import threading
import queue
import zmq
from pathlib import Path

from PySide6.QtCore import Qt, QTimer, Signal, QObject
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QPushButton, QVBoxLayout, QWidget, QFileDialog,
    QHBoxLayout, QLabel, QDialog, QProgressBar
)
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from matplotlib.widgets import RectangleSelector
import pygame

# Reusing code from minimal_example
PROGRAM_NAME = "bye_bye_2_alt"
PROGRAM_AUDIO = "/Users/naddy/Source/Puppet/puppetnet-loader/inputs/bye_bye_2/bye_bye_2.mp3"
PROGRAM_FILE = "/Users/naddy/Source/Puppet/puppetnet-loader/inputs/bye_bye_2/bye_bye_2.json"

PROGRAM_FILE_2 = (Path(PROGRAM_FILE).parent.parent / PROGRAM_NAME) / (PROGRAM_NAME + ".json")
PROGRAM_AUDIO_2 = (Path(PROGRAM_FILE).parent.parent / PROGRAM_NAME) / (PROGRAM_NAME + Path(PROGRAM_AUDIO).suffix)
PROGRAM_DIR_2 = Path(PROGRAM_FILE).parent.parent.parent / "outputs" / "programs" / PROGRAM_NAME

# Global socket to avoid rebinding issues
global_udp_sock = None
global_socket_lock = threading.Lock()

def reset_udp_socket():
    """Force recreate the global UDP socket"""
    global global_udp_sock
    with global_socket_lock:
        try:
            if global_udp_sock is not None:
                global_udp_sock.close()
                global_udp_sock = None
                time.sleep(0.1)  # Allow time for socket to close
        except Exception as e:
            print(f"Error closing socket: {e}")

        # Create a new socket
        try:
            port = 12345
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind(('', port))
            global_udp_sock = sock
            return global_udp_sock
        except Exception as e:
            print(f"Error creating new socket: {e}")
            return None

def get_udp_socket():
    global global_udp_sock
    with global_socket_lock:
        if global_udp_sock is None:
            port = 12345
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                sock.bind(('', port))
                global_udp_sock = sock
            except Exception as e:
                print(f"Error creating socket: {e}")
                return None
        return global_udp_sock

def send_servo(ndx, yval):
    host = os.environ.get("PUPPETNET_IP", '192.168.4.2')
    port = 12345

    udp_sock = get_udp_socket()
    packet = {'dest': 'PUPPET_01', '_type': 'cmd', 'cmd': {'name': 'servo_0', 'state': int(yval)}}
    print(f"Sending packet: {packet}")
    command = json.dumps(packet)
    udp_sock.sendto(command.encode(), (host, port))
    return

def play_on_puppet(frames, values, fps):
    pygame.mixer.init()
    pygame.mixer.music.load(PROGRAM_AUDIO)

    host = os.environ.get("PUPPETNET_IP", '192.168.4.2')
    port = 12345

    udp_sock = get_udp_socket()

    sec_per_frame = 1 / fps
    next_frame = time.time()

    packet = {'dest': 'PUPPET_01', '_type': 'cmd', 'cmd': {'name': 'servo_0', 'state': None}}

    pygame.mixer.music.play()
    for pt in values:
        while True:
            if ((now := time.time()) < next_frame):
                time.sleep(next_frame - now + .0001)
                continue
            packet = {'dest': 'PUPPET_01', '_type': 'cmd', 'cmd': {'name': 'servo_0', 'state': pt}}
            command = json.dumps(packet)
            udp_sock.sendto(command.encode(), (host, port))
            next_frame = time.time() + sec_per_frame
            break
    return

# PS4 Controller Code (from record-animation-with-ps4-controller)
class BaseJoystickSubscriber:
    # Class variable to manage ZMQ context globally
    _global_zmq_context = None
    _zmq_context_lock = threading.Lock()
    _zmq_instances = 0

    @classmethod
    def get_zmq_context(cls):
        """Get or create a global ZMQ context"""
        with cls._zmq_context_lock:
            if cls._global_zmq_context is None:
                cls._global_zmq_context = zmq.Context()
            cls._zmq_instances += 1
            return cls._global_zmq_context

    @classmethod
    def release_zmq_context(cls):
        """Release the global ZMQ context if no more instances are using it"""
        with cls._zmq_context_lock:
            cls._zmq_instances -= 1
            if cls._zmq_instances <= 0 and cls._global_zmq_context is not None:
                try:
                    cls._global_zmq_context.term()
                except Exception as e:
                    print(f"Error terminating ZMQ context: {e}")
                finally:
                    cls._global_zmq_context = None
                    cls._zmq_instances = 0

    def __init__(self, address="tcp://localhost:5555"):
        self.address = address
        self._thread = None
        self._running = False
        self._zmq_socket = None
        # Reference to shared context
        self._context_ref = None

    def process_data(self, data):
        """Override this method to define custom processing logic."""
        raise NotImplementedError("Subclasses must implement process_data")

    def _listen_loop(self):
        try:
            # Get the shared context
            self._context_ref = self.get_zmq_context()

            # Create socket from the shared context
            self._zmq_socket = self._context_ref.socket(zmq.SUB)
            self._zmq_socket.connect(self.address)
            self._zmq_socket.setsockopt_string(zmq.SUBSCRIBE, "")  # Subscribe to all topics

            # Set a shorter timeout for receive operations to make stopping cleaner
            self._zmq_socket.setsockopt(zmq.RCVTIMEO, 50)  # 50ms timeout

            print(f"ZMQ listener started on {self.address}")

            while self._running:
                try:
                    message = self._zmq_socket.recv_string()
                    data = json.loads(message)
                    self.process_data(data)
                except zmq.Again:
                    # Timeout, just loop again to check if we're still running
                    continue
                except json.JSONDecodeError:
                    # Invalid JSON, skip this message
                    continue
                except Exception as e:
                    print(f"Error in controller listen loop: {e}")
                    # Short sleep to avoid spinning CPU
                    time.sleep(0.01)
        except Exception as e:
            print(f"Fatal error in controller thread: {e}")
        finally:
            # Clean up socket
            if self._zmq_socket:
                try:
                    self._zmq_socket.close(linger=0)  # Don't wait for messages to be sent
                except Exception as e:
                    print(f"Error closing ZMQ socket: {e}")
                self._zmq_socket = None

            # Release the shared context
            if self._context_ref:
                self.release_zmq_context()
                self._context_ref = None

            print("ZMQ listener stopped")

    def start(self):
        if self._running:
            print("Subscriber already running, not starting again")
            return

        print("Starting joystick subscriber")
        self._running = True
        self._thread = threading.Thread(target=self._listen_loop, daemon=True)
        self._thread.start()

    def end(self):
        """Tell the thread to stop and clean up resources."""
        if not self._running:
            print("Subscriber not running, nothing to stop")
            return

        print("Stopping joystick subscriber")
        self._running = False

        # Give the thread a moment to clean up
        timeout = 0.5  # Half a second timeout
        start_time = time.time()

        # We'll do a timed join to avoid blocking indefinitely
        if self._thread and self._thread.is_alive():
            remaining = timeout - (time.time() - start_time)
            if remaining > 0:
                self._thread.join(timeout=remaining)

        # Force cleanup if thread is still alive
        if self._thread and self._thread.is_alive():
            print("Thread didn't exit cleanly, forcing cleanup")

            # Force socket cleanup
            if self._zmq_socket:
                try:
                    self._zmq_socket.close(linger=0)
                except:
                    pass
                self._zmq_socket = None

            # Release context reference
            if self._context_ref:
                self.release_zmq_context()
                self._context_ref = None

        self._thread = None
        print("Subscriber cleanup complete")

class LoggingJoystickSubscriber(BaseJoystickSubscriber):
    def __init__(self, address="tcp://localhost:5555"):
        super(LoggingJoystickSubscriber, self).__init__(address)
        return

    def process_data(self, data):
        print("Received joystick data:", data['r3'])
        try:
            num = int(8000 - (data['r3'] + 1) / 2 * (8000-5900))
        except:
            return
        send_servo(0, num)
        return

class QueueingJoystickSubscriber(BaseJoystickSubscriber):
    def __init__(self, address="tcp://localhost:5555", data_callback=None):
        super().__init__(address)
        # Use a list instead of a queue for better reliability
        self.data_points = []
        self.data_callback = data_callback
        self.last_data = None
        # Use a lock to prevent concurrent access issues
        self.queue_lock = threading.Lock()
        # Track timestamps to detect stalled data
        self.last_update_time = time.time()
        self.max_silent_period = 0.5  # Max time without data before warning

        # Start a watchdog timer
        self.watchdog_active = True
        self.watchdog_thread = threading.Thread(target=self._watchdog_loop, daemon=True)
        self.watchdog_thread.start()

    def _watchdog_loop(self):
        """Monitor data flow to detect issues"""
        while self.watchdog_active and self._running:
            time.sleep(0.2)  # Check every 200ms
            now = time.time()
            silent_time = now - self.last_update_time

            if silent_time > self.max_silent_period:
                print(f"WARNING: No controller data for {silent_time:.1f} seconds")

        print("Watchdog thread exiting")

    def process_data(self, data):
        """Process incoming controller data"""
        # Update watchdog timestamp
        self.last_update_time = time.time()

        # Store latest data
        self.last_data = data

        # Only process if r3 exists in data
        if 'r3' in data:
            try:
                # Calculate servo value
                num = int(8000 - (data['r3'] + 1) / 2 * (8000-5900))

                # Store the value
                with self.queue_lock:
                    self.data_points.append(num)

                # Send to puppet while recording
                send_servo(0, num)

                # Call callback if provided
                if self.data_callback:
                    self.data_callback(num)
            except Exception as e:
                print(f"Error processing controller data: {e}")

    def get_recorded_data(self):
        """Return all recorded data points"""
        with self.queue_lock:
            # Return a copy to avoid concurrent modification
            return self.data_points.copy()

    def end(self):
        """Override end to also stop the watchdog"""
        self.watchdog_active = False

        # Stop the main thread
        self._running = False

        # Don't join the thread here as it might block the UI
        # Parent class will handle the rest of cleanup
        super().end()

# Animation Recording Window
class RecordingSignals(QObject):
    recording_complete = Signal(list)

class RecordingWindow(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Record Animation")
        self.resize(500, 200)

        self.mp3_file_path = None
        self.output_dir = None
        self.recorded_data = []
        self.subscriber = None
        self.recording = False
        self.is_connected = False
        self.signals = RecordingSignals()

        layout = QVBoxLayout()

        # File selection
        file_layout = QHBoxLayout()
        self.file_label = QLabel("No MP3 file selected")
        file_layout.addWidget(self.file_label)

        self.browse_button = QPushButton("Browse")
        self.browse_button.clicked.connect(self.browse_mp3)
        file_layout.addWidget(self.browse_button)

        layout.addLayout(file_layout)

        # Buttons
        button_layout = QHBoxLayout()

        self.connect_button = QPushButton("Connect PS4 Controller")
        self.connect_button.clicked.connect(self.toggle_connect)
        button_layout.addWidget(self.connect_button)

        self.play_button = QPushButton("Play MP3")
        self.play_button.clicked.connect(self.play_mp3)
        self.play_button.setEnabled(False)
        button_layout.addWidget(self.play_button)

        layout.addLayout(button_layout)

        # Recording buttons
        record_layout = QHBoxLayout()

        self.record_button = QPushButton("Record (Normal)")
        self.record_button.clicked.connect(lambda: self.record_animation(1.0))
        self.record_button.setEnabled(False)
        record_layout.addWidget(self.record_button)

        self.record_half_button = QPushButton("Record (1/2 Speed)")
        self.record_half_button.clicked.connect(lambda: self.record_animation(0.5))
        self.record_half_button.setEnabled(False)
        record_layout.addWidget(self.record_half_button)

        self.record_quarter_button = QPushButton("Record (1/4 Speed)")
        self.record_quarter_button.clicked.connect(lambda: self.record_animation(0.25))
        self.record_quarter_button.setEnabled(False)
        record_layout.addWidget(self.record_quarter_button)

        layout.addLayout(record_layout)

        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        layout.addWidget(self.progress_bar)

        # Status
        self.status_label = QLabel("Select an MP3 file to begin")
        layout.addWidget(self.status_label)

        self.setLayout(layout)

        # Initialize pygame mixer
        pygame.mixer.init()

    def browse_mp3(self):
        file_dialog = QFileDialog()
        mp3_path, _ = file_dialog.getOpenFileName(
            self, "Select MP3 File", "", "MP3 Files (*.mp3)"
        )

        if mp3_path:
            self.mp3_file_path = mp3_path
            self.file_label.setText(f"File: {os.path.basename(mp3_path)}")

            # Enable all playback and recording buttons
            self.play_button.setEnabled(True)
            self.record_button.setEnabled(True)
            self.record_half_button.setEnabled(True)
            self.record_quarter_button.setEnabled(True)

            # Determine output directory
            base_name = os.path.splitext(os.path.basename(mp3_path))[0]
            self.output_dir = os.path.join("/Users/naddy/Source/Puppet/puppetnet-loader/inputs", base_name)

            self.status_label.setText(f"Ready to use {base_name}")

    def toggle_connect(self):
        if not self.is_connected:
            # Start PS4 controller connection
            self.subscriber = LoggingJoystickSubscriber()
            self.subscriber.start()
            self.is_connected = True
            self.connect_button.setText("Disconnect Controller")
            self.status_label.setText("PS4 Controller connected. Move R3 to control puppet.")
        else:
            # Disconnect
            if self.subscriber:
                self.subscriber.end()
                self.subscriber = None
            self.is_connected = False
            self.connect_button.setText("Connect PS4 Controller")
            self.status_label.setText("PS4 Controller disconnected")

    def play_mp3(self):
        if not self.mp3_file_path:
            return

        pygame.mixer.music.load(self.mp3_file_path)
        pygame.mixer.music.play()

        # Update status
        self.status_label.setText(f"Playing {os.path.basename(self.mp3_file_path)}")

        # Reset status when playback ends
        def check_music_end():
            if not pygame.mixer.music.get_busy():
                self.status_label.setText("Playback finished")
                return
            QTimer.singleShot(100, check_music_end)

        check_music_end()

    def start_countdown(self, speed=1.0):
        """Start a 3-2-1 countdown before recording"""
        # Update the UI to show countdown starting
        self.status_label.setText("Get ready... 3")
        self.repaint()
        
        # Disable all buttons during countdown
        self.connect_button.setEnabled(False)
        self.play_button.setEnabled(False)
        self.record_button.setEnabled(False)
        self.record_half_button.setEnabled(False)
        self.record_quarter_button.setEnabled(False)
        self.browse_button.setEnabled(False)
        
        # Create countdown sequence
        self.countdown_value = 3
        
        # Create countdown timer
        self.countdown_timer = QTimer()
        self.countdown_timer.setInterval(1000)  # 1 second interval
        
        def update_countdown():
            self.countdown_value -= 1
            if self.countdown_value > 0:
                # Continue countdown
                self.status_label.setText(f"Get ready... {self.countdown_value}")
            else:
                # Stop countdown and start recording
                self.countdown_timer.stop()
                self.status_label.setText("Go!")
                # Give a short pause after "Go!" before starting
                QTimer.singleShot(500, lambda: self._start_recording(speed))
                
        self.countdown_timer.timeout.connect(update_countdown)
        self.countdown_timer.start()

    def record_animation(self, speed=1.0):
        """Record animation with the given playback speed (1.0 = normal, 0.5 = half speed, etc.)"""
        if not self.mp3_file_path or self.recording:
            return
            
        # Start the countdown first
        self.start_countdown(speed)

    def _start_recording(self, speed=1.0):
        """Start recording after countdown completes"""
        if not self.mp3_file_path or self.recording:
            return

        # Store the speed for processing later
        self.recording_speed = speed

        # Make sure any previous recording is completely stopped
        if hasattr(self, 'progress_timer') and self.progress_timer.isActive():
            self.progress_timer.stop()

        # Update UI to show we're preparing
        self.status_label.setText("Preparing recording...")
        self.repaint()

        # Ensure we're not still in a recording state
        self.recording = False

        # Completely clean up any existing subscriber
        if self.subscriber:
            try:
                self.subscriber.end()
                # Give it time to clean up
                time.sleep(0.2)
                self.subscriber = None
            except Exception as e:
                print(f"Error cleaning up previous subscriber: {e}")

        # Reset socket to ensure clean state
        reset_udp_socket()

        # Reset recording state
        self.recorded_data = []
        self.recording = True

        # Create a fresh subscriber after a brief delay
        time.sleep(0.2)  # Give system time to clean up resources

        try:
            # Reset pygame mixer to avoid potential conflicts
            pygame.mixer.quit()
            time.sleep(0.1)
            pygame.mixer.init()

            # Create new subscriber
            self.subscriber = QueueingJoystickSubscriber()
            self.subscriber.start()
            self.is_connected = True
        except Exception as e:
            print(f"Error creating subscriber: {e}")
            self.status_label.setText(f"Error: {str(e)}")
            self.recording = False
            return

        # Make a temporary copy of the mp3 file if we're using a different speed
        self.temp_mp3_path = None

        if speed != 1.0:
            # Create a temporary directory if it doesn't exist
            os.makedirs("/tmp/puppetnet", exist_ok=True)

            # Create a temporary slowed-down version of the MP3
            self.temp_mp3_path = f"/tmp/puppetnet/temp_recording_{speed}.mp3"

            # Use sox to create a slowed down version
            subprocess.run(["sox", self.mp3_file_path, self.temp_mp3_path, "tempo", f"{speed}"])

            # Load the slowed-down version
            pygame.mixer.music.load(self.temp_mp3_path)

            # Get duration of the slowed-down MP3
            sound = pygame.mixer.Sound(self.temp_mp3_path)
            duration = sound.get_length()

            self.status_label.setText(f"Recording at {speed:.2f}x speed...")
        else:
            # Start normal playback
            pygame.mixer.music.load(self.mp3_file_path)

            # Get duration of the MP3
            sound = pygame.mixer.Sound(self.mp3_file_path)
            duration = sound.get_length()

        # Show progress bar
        self.progress_bar.setVisible(True)
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)

        # Update button states
        self.connect_button.setText("Recording in progress...")
        self.connect_button.setEnabled(False)
        self.play_button.setEnabled(False)
        self.record_button.setEnabled(False)
        self.record_half_button.setEnabled(False)
        self.record_quarter_button.setEnabled(False)
        self.browse_button.setEnabled(False)

        # Play the MP3
        pygame.mixer.music.play()
        if speed != 1.0:
            self.status_label.setText(f"Recording at {speed:.2f}x speed... Move the right stick (R3) to control puppet!")
        else:
            self.status_label.setText("Recording animation... Move the right stick (R3) to control puppet!")

        # Update progress
        start_time = time.time()

        # Create a timer that checks if recording is complete
        self.progress_timer = QTimer()
        self.progress_timer.setInterval(100)  # 100ms

        def check_progress():
            if not pygame.mixer.music.get_busy():
                # Recording finished
                self.progress_timer.stop()
                # Use QTimer.singleShot to ensure we're on the main thread for UI updates
                QTimer.singleShot(200, self.finish_recording)
                return

            elapsed = time.time() - start_time
            progress = min(100, int(elapsed / duration * 100))
            self.progress_bar.setValue(progress)

        self.progress_timer.timeout.connect(check_progress)
        self.progress_timer.start()

        # Also set a backup timer to ensure recording stops after duration + 0.5 seconds
        QTimer.singleShot(int((duration + 0.5) * 1000), lambda: self.finish_recording() if self.recording else None)

    def finish_recording(self):
        """Safely finish the recording process"""
        # Only proceed if we're actually recording
        if not self.recording:
            return

        # Set recording flag to false immediately to prevent multiple calls
        self.recording = False

        # Immediately capture data to avoid any thread issues
        # We'll copy the data now rather than waiting for thread cleanup
        if self.subscriber and hasattr(self.subscriber, 'data_points'):
            try:
                # Make a clean copy of the data before doing anything else
                with self.subscriber.queue_lock:
                    self.recorded_data = self.subscriber.data_points.copy()
                print(f"Successfully captured {len(self.recorded_data)} data points")
            except Exception as e:
                print(f"Error capturing data: {e}")

        # Stop pygame music playback if it's still going
        try:
            if pygame.mixer.music.get_busy():
                pygame.mixer.music.stop()
        except Exception as e:
            print(f"Error stopping pygame music: {e}")

        # Stop the progress timer if it exists
        if hasattr(self, 'progress_timer'):
            try:
                if self.progress_timer.isActive():
                    self.progress_timer.stop()
            except Exception as e:
                print(f"Error stopping timer: {e}")

        # Update UI immediately to show we're processing
        self.status_label.setText("Processing recording...")

        print("A")
        self.progress_bar.setValue(100)
        self.status_label.setText("Processing recording...B")
        print("B")
        self.repaint()  # Force immediate repaint

        print("C")
        self.status_label.setText("Processing recording...C")

        # CRITICAL: Now we'll complete without doing any resource cleanup or complex thread operations
        # This avoids any potential blocking. We'll re-enable everything immediately.

        # Re-enable all buttons
        self._reactivate_buttons()
        print("D")
        self.status_label.setText("Processing recording...D")
        # Just schedule a very minimal callback to emit the signal with data
        QTimer.singleShot(10, lambda: self._minimal_process_recording())
        self.status_label.setText("Processing recording...")

    def _minimal_process_recording(self):
        """Process recording data with minimal operations to avoid blocking"""
        try:
            # If we have data, handle speed adjustments
            if self.recorded_data:
                # Handle speed adjustment if needed
                if hasattr(self, 'recording_speed') and self.recording_speed != 1.0:
                    speed = self.recording_speed

                    # Calculate target frames
                    target_frames = int(len(self.recorded_data) * speed)

                    if target_frames > 0:
                        # Simple interpolation
                        indices = np.linspace(0, len(self.recorded_data) - 1, target_frames)
                        interpolated_data = [self.recorded_data[int(i)] for i in indices]
                        self.recorded_data = interpolated_data

                # Update status
                self.status_label.setText(f"Recording complete! Captured {len(self.recorded_data)} data points")

                # Send data to main window
                self.signals.recording_complete.emit(self.recorded_data)

                # Save the recording to a fixed location
                self.save_to_fixed_location()
            else:
                self.status_label.setText("Recording complete, but no data was captured")

            # Hide progress bar
            self.progress_bar.setVisible(False)

            # Schedule socket and thread cleanup for later, when it's safe
            threading.Thread(target=self._delayed_cleanup, daemon=True).start()
        except Exception as e:
            print(f"Error in minimal processing: {e}")
            self.status_label.setText("Error processing recording")
            self.progress_bar.setVisible(False)

    def _delayed_cleanup(self):
        """Run cleanup operations in a separate thread after a delay"""
        try:
            # Wait a bit before cleanup
            time.sleep(2.0)

            # Reset mixer
            try:
                pygame.mixer.quit()
                time.sleep(0.2)
                pygame.mixer.init()
            except:
                pass

            # Reset socket
            try:
                reset_udp_socket()
            except:
                pass

            # Clean up subscriber
            if self.subscriber:
                try:
                    old_sub = self.subscriber
                    self.subscriber = None
                    old_sub.end()
                    time.sleep(0.5)
                except:
                    pass

            # Create a new fresh subscriber
            try:
                self.subscriber = LoggingJoystickSubscriber()
                self.subscriber.start()
                self.is_connected = True
            except:
                self.is_connected = False

            print("Delayed cleanup complete")
        except Exception as e:
            print(f"Error in delayed cleanup: {e}")

    def _process_recording_data(self):
        """Process the recorded data - runs after UI has updated"""
        try:
            # Get the recorded data from the subscriber
            if self.subscriber:
                # Use the correct method name to get the recorded data
                self.recorded_data = self.subscriber.get_recorded_data() if hasattr(self.subscriber, 'get_recorded_data') else []

                # Process data if we used a different speed
                if hasattr(self, 'recording_speed') and self.recording_speed != 1.0:
                    # When recording at slower speeds, we need to interpolate the data to match normal speed
                    speed = self.recording_speed

                    # Determine the target number of frames at normal speed
                    # For example, at half speed (0.5), we recorded twice as many frames as needed
                    target_frames = int(len(self.recorded_data) * speed)

                    if target_frames > 0:
                        # Use linear interpolation to reduce the number of frames
                        indices = np.linspace(0, len(self.recorded_data) - 1, target_frames)
                        interpolated_data = [self.recorded_data[int(i)] for i in indices]

                        # Log information about the conversion
                        print(f"Converting recorded data from {self.recording_speed}x speed: "
                              f"{len(self.recorded_data)} frames → {len(interpolated_data)} frames")

                        # Replace the recorded data with the interpolated data
                        self.recorded_data = interpolated_data

                        self.status_label.setText(
                            f"Recording complete! Converted {len(self.recorded_data)} data points to normal speed."
                        )
                    else:
                        self.status_label.setText("Not enough data to convert to normal speed.")

                    # Clean up temporary files
                    if hasattr(self, 'temp_mp3_path') and self.temp_mp3_path:
                        try:
                            if os.path.exists(self.temp_mp3_path):
                                os.remove(self.temp_mp3_path)
                        except Exception as e:
                            print(f"Error removing temporary file: {e}")

                # We create a new subscriber for manual control
                # This ensures we have a clean subscriber state
                try:
                    if self.subscriber:
                        self.subscriber.end()
                        self.subscriber = None

                    # Small delay to ensure cleanup
                    time.sleep(0.1)

                    # Create a fresh subscriber for manual control
                    self.subscriber = LoggingJoystickSubscriber()
                    self.subscriber.start()
                    self.is_connected = True
                    self.connect_button.setText("Disconnect Controller")
                    self.connect_button.setEnabled(True)
                except Exception as e:
                    print(f"Error recreating subscriber: {e}")
                    self.connect_button.setText("Connect PS4 Controller")
                    self.connect_button.setEnabled(True)
                    self.is_connected = False

            # Re-enable buttons with a slight delay to avoid UI collisions
            QTimer.singleShot(100, lambda: self._reactivate_buttons())

            # Save recorded data
            if self.recorded_data:
                if not hasattr(self, 'recording_speed') or self.recording_speed == 1.0:
                    self.status_label.setText(f"Recording complete! Captured {len(self.recorded_data)} data points")

                # Emit signal with recorded data
                self.signals.recording_complete.emit(self.recorded_data)

                # Save recording to fixed location to avoid prompts
                QTimer.singleShot(100, self.save_to_fixed_location)
            else:
                self.status_label.setText("Recording complete, but no data was captured")

            self.progress_bar.setVisible(False)
        except Exception as e:
            print(f"Error processing recording data: {e}")
            self.status_label.setText(f"Error processing recording: {str(e)}")
            self.progress_bar.setVisible(False)
            self._reactivate_buttons()  # Use the helper method for consistency

    def save_to_fixed_location(self):
        """Save to a fixed location (nja_test) to avoid any interactive prompts"""
        if not self.recorded_data:
            return
            
        try:
            # Fixed directory and filenames
            fixed_dir = "/Users/naddy/Source/Puppet/puppetnet-loader/inputs/nja_test"
            fixed_mp3 = "nja_test.mp3"
            fixed_wav = "nja_test.wav"
            fixed_json = "nja_test.json"
            
            # Create directory if needed
            os.makedirs(fixed_dir, exist_ok=True)
            
            # Copy MP3 file - use the source file if available, otherwise use a default
            if self.mp3_file_path:
                # Copy the selected MP3 to the fixed location
                output_mp3_path = os.path.join(fixed_dir, fixed_mp3)
                shutil.copy2(self.mp3_file_path, output_mp3_path)
                
                # Generate WAV using ffmpeg with -y to force overwrite
                output_wav_path = os.path.join(fixed_dir, fixed_wav)
                subprocess.run(["ffmpeg", "-y", "-i", output_mp3_path, output_wav_path], 
                               stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            
            # Create JSON content
            output = {}
            output["servos"] = {"servo_0": {"pin": 0}}
            
            # Create animation history
            output["history"] = [
                {"frame": frame, "servos": {"servo_0": {"triangle": 0.0, "servo": int(val)}}}
                for frame, val in enumerate(self.recorded_data, 1)
            ]
            
            # Write JSON file
            output_json_path = os.path.join(fixed_dir, fixed_json)
            with open(output_json_path, 'w') as outf:
                outf.write(json.dumps(output))
                
            self.status_label.setText(f"Saved recording to {fixed_dir}")
            print(f"Successfully saved animation to {fixed_dir}")
        except Exception as e:
            print(f"Error saving to fixed location: {e}")
            self.status_label.setText("Error saving recording")
    
    def save_recording(self):
        """Original save method (not used anymore)"""
        if not self.mp3_file_path or not self.recorded_data:
            return

        # Create output directory if it doesn't exist
        os.makedirs(self.output_dir, exist_ok=True)

        # Copy MP3 file
        mp3_filename = os.path.basename(self.mp3_file_path)
        output_mp3_path = os.path.join(self.output_dir, mp3_filename)
        shutil.copy2(self.mp3_file_path, output_mp3_path)

        # Generate WAV version if needed
        output_wav_path = os.path.join(self.output_dir, os.path.splitext(mp3_filename)[0] + ".wav")
        subprocess.run(["ffmpeg", "-i", output_mp3_path, output_wav_path])

        # Create JSON file
        base_name = os.path.splitext(os.path.basename(self.mp3_file_path))[0]
        output_json_path = os.path.join(self.output_dir, f"{base_name}.json")

        # Create JSON content
        output = {}
        output["servos"] = {"servo_0": {"pin": 0}}

        # Create animation history
        output["history"] = [
            {"frame": frame, "servos": {"servo_0": {"triangle": 0.0, "servo": int(val)}}}
            for frame, val in enumerate(self.recorded_data, 1)
        ]

        # Write JSON file
        with open(output_json_path, 'w') as outf:
            outf.write(json.dumps(output))

        self.status_label.setText(f"Saved recording to {self.output_dir}")

    def _reactivate_buttons(self):
        """Helper method to consistently re-enable all buttons"""
        # Enable all buttons based on current state
        self.play_button.setEnabled(bool(self.mp3_file_path))
        self.record_button.setEnabled(bool(self.mp3_file_path))
        self.record_half_button.setEnabled(bool(self.mp3_file_path))
        self.record_quarter_button.setEnabled(bool(self.mp3_file_path))
        self.browse_button.setEnabled(True)
        self.connect_button.setEnabled(True)

# Main Animation Editor Window from minimal_example
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Animation Editor")

        # Use the existing MplGraphCanvas from minimal_example
        self.canvas = MplGraphCanvas(self)
        self.canvas.setFocusPolicy(Qt.StrongFocus)
        self.canvas.setFocus()

        self.canvas.keyPressEvent = self.canvas.key_press_event
        self.canvas.keyReleaseEvent = self.canvas.key_release_event

        self.save_button = QPushButton("Save")
        self.save_button.clicked.connect(self.canvas.upload_and_play_program)

        self.load_button = QPushButton("Load")
        self.load_button.clicked.connect(self.load_from_csv)

        # New button for recording animation
        self.record_animation_button = QPushButton("Record New Animation")
        self.record_animation_button.clicked.connect(self.open_recording_window)

        layout = QVBoxLayout()
        layout.addWidget(self.canvas)

        # Add mode toggle button
        self.toggle_button = QPushButton("Switch to Select Mode")
        self.toggle_button.clicked.connect(self.toggle_mode)
        layout.addWidget(self.toggle_button)

        # Main button layout
        button_layout = QHBoxLayout()
        button_layout.addWidget(self.load_button)
        button_layout.addWidget(self.save_button)
        button_layout.addWidget(self.record_animation_button)
        layout.addLayout(button_layout)
        
        # Add playback speed buttons
        playback_layout = QHBoxLayout()
        
        self.play_normal_button = QPushButton("Play")
        self.play_normal_button.clicked.connect(lambda: self.upload_and_play_nja_test(1.0))
        playback_layout.addWidget(self.play_normal_button)
        
        self.play_half_button = QPushButton("Play 1/2")
        self.play_half_button.clicked.connect(lambda: self.upload_and_play_nja_test(0.5))
        playback_layout.addWidget(self.play_half_button)
        
        self.play_quarter_button = QPushButton("Play 1/4")
        self.play_quarter_button.clicked.connect(lambda: self.upload_and_play_nja_test(0.25))
        playback_layout.addWidget(self.play_quarter_button)
        
        layout.addLayout(playback_layout)

        container = QWidget()
        container.setLayout(layout)
        self.setCentralWidget(container)

        self.load_file(PROGRAM_FILE)

    def toggle_mode(self):
        if self.canvas.mode == "click":
            self.canvas.mode = "select"
            self.toggle_button.setText("Switch to Click Mode")
            self.canvas.selector.set_active(True)
        else:
            self.canvas.mode = "click"
            self.toggle_button.setText("Switch to Select Mode")
            self.canvas.selector.set_active(False)

    def load_file(self, fname):
        data = json.loads(open(fname).read())
        servo_name = list(data["servos"].keys())[0]

        frames = [d['frame'] for d in data["history"]]
        frames = [int(x) - 1 for x in frames]

        values = [d["servos"][servo_name]["servo"] for d in data["history"]]

        self.canvas.curve.x = frames
        self.canvas.curve.y = values
        self.canvas.line.set_data(self.canvas.curve.x, self.canvas.curve.y)
        self.update_view()

        self.canvas.control_indices = []
        self.canvas.update_control_display()
        self.canvas.draw_idle()
        self.canvas.set_draggable_points()
        print(f"Loaded from {fname}")
        return

    def update_view(self):
        self.canvas.update_view()
        return

    def load_from_csv(self):
        self.load_file(PROGRAM_FILE)
        return
        
    def upload_and_play_nja_test(self, tempo=1.0):
        """Upload and play the animation from the fixed nja_test location with specified tempo"""
        # Define the fixed paths
        NJA_NAME = "nja_test"
        NJA_DIR = "/Users/naddy/Source/Puppet/puppetnet-loader/inputs/nja_test"
        NJA_JSON = os.path.join(NJA_DIR, "nja_test.json")
        NJA_MP3 = os.path.join(NJA_DIR, "nja_test.mp3")
        NJA_OUTPUT_DIR = "/Users/naddy/Source/Puppet/puppetnet-loader/outputs/programs/nja_test"
        
        # Create the output directory if it doesn't exist
        os.makedirs(NJA_OUTPUT_DIR, exist_ok=True)
        
        # Ensure the files exist
        if not os.path.exists(NJA_JSON) or not os.path.exists(NJA_MP3):
            print(f"Error: Required files not found in {NJA_DIR}")
            return
            
        print(f"Playing nja_test at {tempo}x speed")
        
        # First, copy the current curve data to the fixed location
        output = {}
        output["servos"] = {"servo_0": {"pin": 0}}
        
        output["history"] = [
            {"frame": frame * 1/tempo, "servos": {"servo_0": {"triangle": 0.0, "servo": int(val)}}}
            for frame, val in enumerate(self.canvas.curve.y, 1)
        ]
        
        # Write the JSON file
        with open(NJA_JSON, 'w') as outf:
            outf.write(json.dumps(output))

        # Compile the animation
        time.sleep(.5)
        subprocess.run(["./bin/compile-animation", NJA_JSON, NJA_MP3, NJA_OUTPUT_DIR, 
                        "--force", "--frame-rate", str(self.canvas.fps)])

        # Apply tempo if needed
        if tempo != 1.0:
            name = os.path.join(NJA_OUTPUT_DIR, os.path.basename(NJA_MP3))
            backup = name + ".bak"
            new_file = name + ".new.mp3"
            
            # Make a backup
            shutil.copy2(name, backup)
            
            # Apply tempo change
            result = subprocess.run(["sox", name, new_file, "tempo", f"{tempo}"])
            
            # Replace the original
            shutil.copy2(new_file, name)
            os.remove(new_file)
            time.sleep(1.0)

        # Upload the program
        subprocess.run(["bin/upload-program", NJA_OUTPUT_DIR])
        time.sleep(1.0)
        
        # Play the program
        subprocess.run(["./bin/dev_cmd", "PUPPET_01", "play", NJA_NAME])
        return

    def open_recording_window(self):
        # Create and show the recording window
        self.recording_window = RecordingWindow(self)

        # Connect signal to handle recorded data
        self.recording_window.signals.recording_complete.connect(self.process_recorded_data)

        self.recording_window.exec()

    def process_recorded_data(self, data):
        if not data:
            return

        # Update the curve with the recorded data
        frames = list(range(len(data)))
        values = data

        self.canvas.curve.x = frames
        self.canvas.curve.y = values
        self.canvas.line.set_data(self.canvas.curve.x, self.canvas.curve.y)
        self.update_view()

        self.canvas.control_indices = []
        self.canvas.update_control_display()
        self.canvas.draw_idle()
        self.canvas.set_draggable_points()

# Include the necessary classes from minimal_example
def unpacker(f):
    def alt_f(self, **kwds):
        d = f(self, **kwds)
        return tuple(d[k] for k in kwds)
    return alt_f

class HistoryManager:
    def __init__(self):
        self.history_ptr = -1
        self.history_states = []

    def record_history(self, **kwds):
        # Trim future states if we're in the middle
        if self.history_ptr < len(self.history_states) - 1:
            self.history_states = self.history_states[:self.history_ptr + 1]

        # Append a deepcopy of the current state
        self.history_states.append(copy.deepcopy(kwds))
        self.history_ptr += 1

    @unpacker
    def undo(self, **kwds):
        if self.history_ptr <= 0:
            return kwds

        self.history_ptr -= 1
        past_state = self.history_states[self.history_ptr]
        return {k: past_state.get(k, kwds[k]) for k in kwds}

    @unpacker
    def redo(self, **kwds):
        if self.history_ptr >= len(self.history_states) - 1:
            return kwds  # Nothing to redo

        self.history_ptr += 1
        future_state = self.history_states[self.history_ptr]
        return {k: future_state.get(k, kwds[k]) for k in kwds}

class PlottedCurve:
    def __init__(self, x=None, y=None):
        self._x = np.array(x) if x is not None else np.array([])
        self._y = np.array(y) if y is not None else np.array([])

    @property
    def x(self):
        return self._x

    @x.setter
    def x(self, new_x):
        self._x = np.array(new_x)

    @property
    def y(self):
        return self._y

    @y.setter
    def y(self, new_y):
        self._y = np.array(new_y)

    def get_data(self):
        return self._x, self._y

    def set_data(self, x, y):
        self._x = np.array(x)
        self._y = np.array(y)

    def __len__(self):
        return len(self._x)

class MplGraphCanvas(FigureCanvas):
    def __init__(self, parent=None):
        self.fps = 24
        self.mode = "click"
        self.shift_down = False
        self.ctrl_down = False
        self.meta_down = False
        self.alt_down = False

        self.undo_manager = HistoryManager()

        self.fig = Figure()
        super().__init__(self.fig)
        self.ax = self.fig.add_subplot(111)

        self.ax.axhline(8000, color='lightgrey', linewidth=1, linestyle='--', zorder=0)
        self.ax.axhline(5900, color='lightgrey', linewidth=1, linestyle='--', zorder=0)

        self.curve = PlottedCurve(np.linspace(0, 10, 100), np.sin(np.linspace(0, 10, 100)))
        self.line, = self.ax.plot(self.curve.x, self.curve.y, color='dimgray', linestyle='-')

        self.last_drag_y = None
        self.setParent(parent)

        self.selected_indices = []
        self.last_selected_indices = []
        self.range_indices = []

        self.selector = RectangleSelector(
            self.ax,
            onselect=self.on_select,
            useblit=True,
            button=[1],
            minspanx=5, minspany=5,
            spancoords='pixels'
        )
        self.selector.set_active(False)

        self.control_scatter = self.ax.scatter([], [], color='red', zorder=5)
        self.set_draggable_points()

        self.dragging = None

        self.mpl_connect("button_press_event", self.on_click)
        self.mpl_connect("motion_notify_event", self.on_drag)
        self.mpl_connect("button_release_event", self.on_release)

        return

    def record_history(self):
        return self.undo_manager.record_history(
            curve=self.curve,
            selected=self.selected_indices,
            fps=self.fps,
        )

    def undo(self):
        (self.curve, self.selected_indices, self.fps) = (
            self.undo_manager.undo(curve=self.curve, selected=self.selected_indices, fps=self.fps)
        )
        return None

    def redo(self):
        (self.curve, self.selected_indices, self.fps) = (
            self.undo_manager.redo(curve=self.curve, selected=self.selected_indices, fps=self.fps)
        )
        return

    def insert_point_at_start(self):
        # Get current curve data
        self.record_history()

        xx = [0] + [(n+1) for n in self.curve.x]
        yy = [self.curve.y[0]] + self.curve.y.tolist()

        self.curve.set_data(xx, yy)
        self.selected_indices = [(n+1) for n in self.selected_indices]

        self.highlight_selected()

        self.update_curve()
        self.draw_idle()
        self.setFocus()
        self.update_view()

        return

    def delete_point_at_start(self):
        # Get current curve data
        self.record_history()

        xx = [(n-1) for n in self.curve.x[1:]]
        yy = self.curve.y.tolist()[1:]

        self.curve.set_data(xx, yy)
        self.selected_indices = [(n-1) for n in self.selected_indices]

        self.highlight_selected()

        self.update_curve()
        self.draw_idle()
        self.setFocus()
        self.update_view()

        return

    def update_view(self):
        self.ax.relim()
        self.ax.autoscale_view(scalex=True, scaley=False)
        self.ax.set_ylim(4000, 8300)
        return

    def key_press_event(self, event):
        if event.key() == Qt.Key_Shift:
            self.shift_down = True
        if event.key() == Qt.Key_Control:
            self.control_down = True
        if event.key() == Qt.Key_Meta:
            self.meta_down = True
        if event.key() == Qt.Key_Alt:
            self.alt_down = True

        text = event.text().lower()
        print(text)

        if text == 's' and self.mode != "select":
            self.mode = "select"
            self.selector.set_active(True)
        elif text == 'q':
            self.undo()
            self.update_curve()
            self.draw_idle()
            self.setFocus()
            self.update_view()
        elif text == 'e':
            self.redo()
            self.update_curve()
            self.draw_idle()
            self.setFocus()
            self.update_view()
        elif text == 'x':
            if not self.selected_indices and self.last_selected_indices:
                self.selected_indices = self.last_selected_indices
            else:
                self.last_selected_indices = self.selected_indices
                self.selected_indices = []
            self.highlight_selected()
        elif text == 'i':
            if not self.shift_down:
                self.insert_point_at_start()
            else:
                self.delete_point_at_start()

        elif text == '1':
            self.upload_and_play_program(tempo=1.0)
        elif text == '2':
            self.upload_and_play_program(tempo=.5)
        elif text == '3':
            self.upload_and_play_program(tempo=.25)

        elif text == '+':
            # Double Resolution
            xx, yy = double_resolution(self.curve.x, self.curve.y)
            self.record_history()
            self.fps *= 2
            self.curve.set_data(xx, yy)
            self.selected_indices = []
            self.highlight_selected()

            self.update_curve()
            self.draw_idle()
            self.setFocus()
            self.update_view()

        elif text == 'p':
            xx = self.curve.x.tolist()
            yy = self.curve.y.tolist()

            if not self.shift_down:
                xx = [xx[ndx] for ndx in self.selected_indices]
                yy = [yy[ndx] for ndx in self.selected_indices]

            play_on_puppet(xx, yy, self.fps)
        return

    def key_release_event(self, event):
        if event.key() == Qt.Key_Shift:
            self.shift_down = False
        if event.key() == Qt.Key_Control:
            self.control_down = False
        if event.key() == Qt.Key_Meta:
            self.meta_down = False
        if event.key() == Qt.Key_Alt:
            self.alt_down = False

        text = event.text().lower()
        if text == 's' and self.mode == "select":
            self.mode = "click"
            self.selector.set_active(False)
        return

    def update_curve(self):
        self.line.set_data(self.curve.x, self.curve.y)
        self.ax.relim()
        self.ax.autoscale_view(scalex=True, scaley=False)
        self.ax.set_ylim(5000, 8000)
        self.update_control_display()
        self.draw_idle()

    def set_draggable_points(self):
        if hasattr(self, 'control_scatter'):
            self.control_scatter.remove()
        self.control_scatter = self.ax.scatter(self.curve.x, self.curve.y, color='black', marker='x', zorder=5)
        self.draw_idle()
        return

    def on_select(self, eclick, erelease):
        if self.mode != "select":
            return

        x0, x1 = sorted([eclick.xdata, erelease.xdata])
        y0, y1 = sorted([eclick.ydata, erelease.ydata])

        if self.shift_down:
            for i in range(len(self.curve.x)):
                x, y = self.curve.x[i], self.curve.y[i]
                if x0 <= x <= x1 and y0 <= y <= y1:
                    if i in self.selected_indices:
                        self.selected_indices.remove(i)
                    else:
                        self.selected_indices.append(i)
        else:
            self.selected_indices = []
            for i in range(len(self.curve.x)):
                x, y = self.curve.x[i], self.curve.y[i]
                if x0 <= x <= x1 and y0 <= y <= y1:
                    self.selected_indices.append(i)

        self.highlight_selected()
        return

    def highlight_selected(self):
        if not self.selected_indices:
            self.control_scatter.set_facecolors('black')
            self.draw_idle()
            return

        facecolors = ['green' if ndx in self.selected_indices else 'black' for ndx in range(len(self.curve.x))]
        facecolors = ['blue' if ndx in self.range_indices else color for (ndx, color) in enumerate(facecolors)]

        self.control_scatter.set_facecolors(facecolors)
        self.draw_idle()

        return

    def on_click(self, event):
        if self.mode != "click" or event.inaxes != self.ax:
            return

        self.record_history()

        # Selected point
        x_click = event.xdata
        idx = np.argmin(np.abs(self.curve.x - x_click))
        self.dragging = idx
        self.last_drag_y = event.ydata

        # What do we do with it
        if self.shift_down:
            if idx in self.selected_indices:
                self.selected_indices.remove(idx)
            else:
                self.selected_indices.append(idx)
        elif self.ctrl_down:
            if idx in self.range_indices:
                self.range_indices.remove(idx)
            else:
                self.range_indices.append(idx)
                self.range_indices = self.range_indices[-2:]
        else:
            # self.selected_indices = [idx]
            self.undo_pending = True  # record undo once on first drag

        self.highlight_selected()
        self.update_control_display()
        return

    def on_drag(self, event):
        if self.mode == "click":
            # Send signal to puppet
            send_servo(0, event.ydata)

        if self.mode != "click" or self.dragging is None or event.inaxes != self.ax:
            return

        if event.ydata is None or self.last_drag_y is None:
            return

        dy = event.ydata - self.last_drag_y
        self.last_drag_y = event.ydata

        # Fix this NJA
        # Figure out the new curve in advance.
        new_ys = self.curve.y.copy()
        if self.dragging in self.selected_indices:
            for i in self.selected_indices:
                new_y = new_ys[i] + dy
                if not (5000 <= new_y <= 8000):
                    return
                new_ys[i] = new_y
        else:
            new_y = event.ydata
            if not (5000 <= new_y <= 8000):
                return
            new_ys[self.dragging] = new_y


        # Save current state for undo before applying changes
        if getattr(self, "undo_pending", True):
            self.record_history()
            self.undo_pending = False

        self.curve.y = new_ys
        self.line.set_ydata(self.curve.y)
        self.update_control_display()
        self.draw_idle()
        return

    def on_release(self, event):
        if self.mode == "click":
            self.dragging = None
            self.last_drag_y = None

    def update_control_display(self):
        x_vals = self.curve.x[:]
        y_vals = self.curve.y[:]
        self.control_scatter.set_offsets(np.column_stack([x_vals, y_vals]))
        self.draw_idle()
        return

    def upload_and_play_program(self, tempo=1.0):
        self.save_to_csv(tempo=tempo)

        print(f"TEMPO: {tempo}")

        time.sleep(.5)
        subprocess.run(["./bin/compile-animation", PROGRAM_FILE_2, PROGRAM_AUDIO_2, PROGRAM_DIR_2, "--force", "--frame-rate", str(self.fps)])

        if tempo != 1.0:
            name = PROGRAM_DIR_2 / PROGRAM_AUDIO_2.name
            shutil.copy2(PROGRAM_AUDIO_2, str(PROGRAM_DIR_2 / PROGRAM_AUDIO_2.name) + ".bak")

            result = subprocess.run(["sox", name, str(name) + ".new.mp3", "tempo", f"{tempo}"])
            shutil.copy2(str(name) + ".new.mp3", str(name))
            os.remove(str(name) + ".new.mp3")
            time.sleep(1.0)

        subprocess.run(["bin/upload-program", PROGRAM_DIR_2])
        time.sleep(1.0)
        subprocess.run(["./bin/dev_cmd", "PUPPET_01", "play", PROGRAM_NAME])
        return

    def save_to_csv(self, tempo=1.0):
        output = {}
        output["servos"] = json.loads(open(PROGRAM_FILE).read())["servos"]
        servo_name = list(json.loads(open(PROGRAM_FILE).read())["servos"].keys())[0]

        output["history"] = [
            {"frame": frame * 1/tempo, "servos": {servo_name: {"triangle": 0.0, "servo": int(val)}}}
            for frame, val in enumerate(self.curve.y, 1)
        ]

        prog_dir = (Path(PROGRAM_FILE).parent.parent / PROGRAM_NAME)
        prog_dir.mkdir(parents=True, exist_ok=True)

        outf_name = (Path(PROGRAM_FILE).parent.parent / PROGRAM_NAME) / (PROGRAM_NAME + ".json")

        with open(outf_name, 'w') as outf:
            outf.write(json.dumps(output))

        output_audio_f = (Path(PROGRAM_FILE).parent.parent / PROGRAM_NAME) / (PROGRAM_NAME + Path(PROGRAM_AUDIO).suffix)

        print(f"Copying {PROGRAM_AUDIO} to {output_audio_f}")
        shutil.copy2(PROGRAM_AUDIO, output_audio_f)
        return

def double_resolution(x, y):
    x = np.asarray(x)
    y = np.asarray(y)

    new_x = np.empty(2 * len(x) - 1, dtype=float)
    new_y = np.empty_like(new_x)

    new_x[::2] = x
    new_x[1::2] = (x[:-1] + x[1:]) / 2

    new_y[::2] = y
    new_y[1::2] = (y[:-1] + y[1:]) / 2  # Linear interpolation

    return list(map(int, (2 * new_x).tolist())), list(map(int, new_y.tolist()))

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.resize(1920, 1080)

    screens = app.screens()

    if len(screens) > 1:
        other_screen = screens[0]  # Index 0 is primary, 1 is usually the second screen
        geometry = other_screen.geometry()
        window.move(geometry.topLeft())

    window.show()
    sys.exit(app.exec())
