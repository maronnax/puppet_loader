#!/usr/bin/env python3

import shutil
import subprocess
import sys
import numpy as np
import json
import copy
import time
import os
import socket
import threading
import queue
import zmq
from pathlib import Path

from PySide6.QtCore import Qt, QTimer, Signal, QObject
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QPushButton, QVBoxLayout, QWidget, QFileDialog,
    QHBoxLayout, QLabel, QDialog, QProgressBar
)
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from matplotlib.widgets import RectangleSelector
import pygame

# Default paths for saving animations
NJA_DIR = "/Users/naddy/Source/Puppet/puppetnet-loader/inputs/nja_test"
NJA_JSON = os.path.join(NJA_DIR, "nja_test.json") 
NJA_MP3 = os.path.join(NJA_DIR, "nja_test.mp3")
NJA_WAV = os.path.join(NJA_DIR, "nja_test.wav")
NJA_OUTPUT_DIR = "/Users/naddy/Source/Puppet/puppetnet-loader/outputs/programs/nja_test"
NJA_NAME = "nja_test"

# Current loaded animation paths (will be set when user loads a file)
CURRENT_MP3 = None
CURRENT_JSON = None

# Socket Service for queue-based communication with the puppet
class SocketService:
    _instance = None
    _lock = threading.Lock()
    
    @classmethod
    def get_instance(cls):
        """Singleton pattern to get the global socket service"""
        with cls._lock:
            if cls._instance is None:
                cls._instance = SocketService()
            return cls._instance
    
    def __init__(self):
        self.command_queue = queue.Queue()
        self.socket = None
        self.service_thread = None
        self.running = False
        self.host = os.environ.get("PUPPETNET_IP", '192.168.4.2')
        self.port = 12345
        self.current_user = None
        self.is_locked = False
        
        # Start the service thread
        self.start_service()
    
    def start_service(self):
        """Start the socket service thread"""
        if self.service_thread is not None and self.service_thread.is_alive():
            return
            
        self.running = True
        self.service_thread = threading.Thread(target=self._service_loop, daemon=True)
        self.service_thread.start()
        print("Socket service started")
    
    def stop_service(self):
        """Stop the socket service thread"""
        self.running = False
        if self.service_thread:
            self.service_thread.join(timeout=1.0)
        self._close_socket()
        print("Socket service stopped")
    
    def _ensure_socket(self):
        """Create socket if needed"""
        if self.socket is None:
            try:
                self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                # Non-blocking for the service thread
                self.socket.setblocking(False)
                return True
            except Exception as e:
                print(f"Error creating socket: {e}")
                return False
        return True
    
    def _close_socket(self):
        """Close the socket safely"""
        if self.socket:
            try:
                self.socket.close()
            except Exception as e:
                print(f"Error closing socket: {e}")
            finally:
                self.socket = None
    
    def _service_loop(self):
        """Main service loop that processes the command queue"""
        last_activity = time.time()
        
        while self.running:
            try:
                # Get commands from queue with timeout
                try:
                    command, user_id, callback = self.command_queue.get(timeout=0.1)
                    last_activity = time.time()
                    
                    # Process command
                    if self._ensure_socket():
                        try:
                            # Send the command
                            self.socket.sendto(command.encode(), (self.host, self.port))
                            if callback:
                                callback(True)
                        except Exception as e:
                            print(f"Error sending command: {e}")
                            # Try to recreate socket
                            self._close_socket()
                            if callback:
                                callback(False)
                    else:
                        if callback:
                            callback(False)
                    
                    # Mark task as done
                    self.command_queue.task_done()
                    
                except queue.Empty:
                    # No commands waiting, check inactivity
                    if time.time() - last_activity > 30.0:  # 30 second inactivity timeout
                        self._close_socket()  # Close socket during inactivity
            
            except Exception as e:
                print(f"Error in socket service loop: {e}")
                time.sleep(0.1)  # Avoid tight loop on error
        
        # Clean up when loop exits
        self._close_socket()
    
    def send_command(self, data, user_id="anonymous", callback=None):
        """Add a command to the queue for sending"""
        if isinstance(data, dict):
            command = json.dumps(data)
        else:
            command = data
            
        # Add to queue for async processing
        self.command_queue.put((command, user_id, callback))
        return True
    
    def lock_service(self, user_id):
        """Lock the service for exclusive use"""
        if self.is_locked and self.current_user != user_id:
            print(f"Service already locked by {self.current_user}, cannot lock for {user_id}")
            return False
            
        self.is_locked = True
        self.current_user = user_id
        print(f"Service locked by {user_id}")
        return True
    
    def unlock_service(self, user_id):
        """Unlock the service"""
        if self.is_locked and self.current_user != user_id and user_id != "force":
            print(f"Service locked by {self.current_user}, cannot unlock by {user_id}")
            return False
            
        self.is_locked = False
        self.current_user = None
        print(f"Service unlocked by {user_id}")
        return True

# Global helper functions for the socket service
def send_servo(ndx, yval, owner="send_servo"):
    """Send a servo command using the socket service"""
    try:
        yval = int(yval)
    except:
        return False
        
    # Create the packet
    packet = {'dest': 'PUPPET_01', '_type': 'cmd', 'cmd': {'name': 'servo_0', 'state': yval}}
    
    # Send to service queue
    service = SocketService.get_instance()
    return service.send_command(packet, owner)

def play_on_puppet(frames, values, fps):
    """Play animation on puppet using socket service"""
    pygame.mixer.init()
    
    # Use the current audio file from nja_test
    if os.path.exists(NJA_MP3):
        pygame.mixer.music.load(NJA_MP3)
    else:
        print(f"Warning: No audio file found at {NJA_MP3}")
        # Create a dummy silent audio file if needed
        if not os.path.exists(NJA_DIR):
            os.makedirs(NJA_DIR, exist_ok=True)
        # Return without playing if no audio
        return False
    
    service = SocketService.get_instance()
    owner_name = "play_on_puppet"
    
    # Try to lock the service for exclusive use during playback
    if not service.lock_service(owner_name):
        print("Could not lock socket service for animation playback")
        return False
    
    sec_per_frame = 1 / fps
    next_frame = time.time()
    success = True
    
    try:
        pygame.mixer.music.play()
        for pt in values:
            while True:
                if ((now := time.time()) < next_frame):
                    time.sleep(next_frame - now + .0001)
                    continue
                
                packet = {'dest': 'PUPPET_01', '_type': 'cmd', 'cmd': {'name': 'servo_0', 'state': pt}}
                service.send_command(packet, owner_name)
                next_frame = time.time() + sec_per_frame
                break
    except Exception as e:
        print(f"Error in play_on_puppet: {e}")
        success = False
    finally:
        # Always unlock the service when done
        service.unlock_service(owner_name)
        return success

# Compatibility functions for existing code
def reset_udp_socket():
    """For compatibility with existing code - no longer needed but provided for compatibility"""
    service = SocketService.get_instance()
    service.unlock_service("force")
    return True

def get_udp_socket(owner="default"):
    """For compatibility with existing code - pretends to get a socket but uses service"""
    service = SocketService.get_instance()
    service.lock_service(owner)
    return True  # Just return true as we don't need actual socket references anymore

def release_udp_socket(owner="default"):
    """For compatibility with existing code - releases service lock"""
    service = SocketService.get_instance()
    return service.unlock_service(owner)

# PS4 Controller Code (from record-animation-with-ps4-controller)
class BaseJoystickSubscriber:
    # Class variable to manage ZMQ context globally
    _global_zmq_context = None
    _zmq_context_lock = threading.Lock()
    _zmq_instances = 0

    @classmethod
    def get_zmq_context(cls):
        """Get or create a global ZMQ context"""
        with cls._zmq_context_lock:
            if cls._global_zmq_context is None:
                cls._global_zmq_context = zmq.Context()
            cls._zmq_instances += 1
            return cls._global_zmq_context

    @classmethod
    def release_zmq_context(cls):
        """Release the global ZMQ context if no more instances are using it"""
        with cls._zmq_context_lock:
            cls._zmq_instances -= 1
            if cls._zmq_instances <= 0 and cls._global_zmq_context is not None:
                try:
                    cls._global_zmq_context.term()
                except Exception as e:
                    print(f"Error terminating ZMQ context: {e}")
                finally:
                    cls._global_zmq_context = None
                    cls._zmq_instances = 0

    def __init__(self, address="tcp://localhost:5555"):
        self.address = address
        self._thread = None
        self._running = False
        self._zmq_socket = None
        # Reference to shared context
        self._context_ref = None

    def process_data(self, data):
        """Override this method to define custom processing logic."""
        raise NotImplementedError("Subclasses must implement process_data")

    def _listen_loop(self):
        try:
            # Get the shared context
            self._context_ref = self.get_zmq_context()

            # Create socket from the shared context
            self._zmq_socket = self._context_ref.socket(zmq.SUB)
            self._zmq_socket.connect(self.address)
            self._zmq_socket.setsockopt_string(zmq.SUBSCRIBE, "")  # Subscribe to all topics

            # Set a shorter timeout for receive operations to make stopping cleaner
            self._zmq_socket.setsockopt(zmq.RCVTIMEO, 50)  # 50ms timeout

            print(f"ZMQ listener started on {self.address}")

            while self._running:
                try:
                    message = self._zmq_socket.recv_string()
                    data = json.loads(message)
                    self.process_data(data)
                except zmq.Again:
                    # Timeout, just loop again to check if we're still running
                    continue
                except json.JSONDecodeError:
                    # Invalid JSON, skip this message
                    continue
                except Exception as e:
                    print(f"Error in controller listen loop: {e}")
                    # Short sleep to avoid spinning CPU
                    time.sleep(0.01)
        except Exception as e:
            print(f"Fatal error in controller thread: {e}")
        finally:
            # Clean up socket
            if self._zmq_socket:
                try:
                    self._zmq_socket.close(linger=0)  # Don't wait for messages to be sent
                except Exception as e:
                    print(f"Error closing ZMQ socket: {e}")
                self._zmq_socket = None

            # Release the shared context
            if self._context_ref:
                self.release_zmq_context()
                self._context_ref = None

            print("ZMQ listener stopped")

    def start(self):
        if self._running:
            print("Subscriber already running, not starting again")
            return

        print("Starting joystick subscriber")
        self._running = True
        self._thread = threading.Thread(target=self._listen_loop, daemon=True)
        self._thread.start()

    def end(self):
        """Tell the thread to stop and clean up resources."""
        if not self._running:
            print("Subscriber not running, nothing to stop")
            return

        print("Stopping joystick subscriber")
        self._running = False

        # Give the thread a moment to clean up
        timeout = 0.5  # Half a second timeout
        start_time = time.time()

        # We'll do a timed join to avoid blocking indefinitely
        if self._thread and self._thread.is_alive():
            remaining = timeout - (time.time() - start_time)
            if remaining > 0:
                self._thread.join(timeout=remaining)

        # Force cleanup if thread is still alive
        if self._thread and self._thread.is_alive():
            print("Thread didn't exit cleanly, forcing cleanup")

            # Force socket cleanup
            if self._zmq_socket:
                try:
                    self._zmq_socket.close(linger=0)
                except:
                    pass
                self._zmq_socket = None

            # Release context reference
            if self._context_ref:
                self.release_zmq_context()
                self._context_ref = None

        self._thread = None
        print("Subscriber cleanup complete")

class LoggingJoystickSubscriber(BaseJoystickSubscriber):
    def __init__(self, address="tcp://localhost:5555"):
        super(LoggingJoystickSubscriber, self).__init__(address)
        return

    def process_data(self, data):
        print("Received joystick data:", data['r3'])
        try:
            num = int(8000 - (data['r3'] + 1) / 2 * (8000-5900))
        except:
            return
        send_servo(0, num)
        return

class QueueingJoystickSubscriber(BaseJoystickSubscriber):
    def __init__(self, address="tcp://localhost:5555", data_callback=None):
        super().__init__(address)
        # Use a list instead of a queue for better reliability
        self.data_points = []
        self.data_callback = data_callback
        self.last_data = None
        # Use a lock to prevent concurrent access issues
        self.queue_lock = threading.Lock()
        # Track timestamps to detect stalled data
        self.last_update_time = time.time()
        self.max_silent_period = 0.5  # Max time without data before warning

        # Start a watchdog timer
        self.watchdog_active = True
        self.watchdog_thread = threading.Thread(target=self._watchdog_loop, daemon=True)
        self.watchdog_thread.start()

    def _watchdog_loop(self):
        """Monitor data flow to detect issues"""
        while self.watchdog_active and self._running:
            time.sleep(0.2)  # Check every 200ms
            now = time.time()
            silent_time = now - self.last_update_time

            if silent_time > self.max_silent_period:
                print(f"WARNING: No controller data for {silent_time:.1f} seconds")

        print("Watchdog thread exiting")

    def process_data(self, data):
        """Process incoming controller data"""
        # Update watchdog timestamp
        self.last_update_time = time.time()

        # Store latest data
        self.last_data = data

        # Only process if r3 exists in data
        if 'r3' in data and data['r3'] is not None:
            try:
                # Calculate servo value
                num = int(8000 - (data['r3'] + 1) / 2 * (8000-5900))
            except:
                return

            try:
                # Store the value
                with self.queue_lock:
                    self.data_points.append(num)

                # Send to puppet while recording
                send_servo(0, num)

                # Call callback if provided
                if self.data_callback:
                    self.data_callback(num)
            except Exception as e:
                print(f"Error processing controller data: {e}")

    def get_recorded_data(self):
        """Return all recorded data points"""
        with self.queue_lock:
            # Return a copy to avoid concurrent modification
            return self.data_points.copy()

    def end(self):
        """Override end to also stop the watchdog"""
        self.watchdog_active = False

        # Stop the main thread
        self._running = False

        # Don't join the thread here as it might block the UI
        # Parent class will handle the rest of cleanup
        super().end()

# Animation Recording Window
class RecordingSignals(QObject):
    recording_complete = Signal(list)

class RecordingWindow(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Record Animation")
        self.resize(500, 200)

        self.mp3_file_path = None
        self.output_dir = None
        self.recorded_data = []
        self.subscriber = None
        self.recording = False
        self.is_connected = False
        self.signals = RecordingSignals()

        layout = QVBoxLayout()

        # File selection
        file_layout = QHBoxLayout()
        self.file_label = QLabel("No MP3 file selected")
        file_layout.addWidget(self.file_label)

        self.browse_button = QPushButton("Browse")
        self.browse_button.clicked.connect(self.browse_mp3)
        file_layout.addWidget(self.browse_button)

        layout.addLayout(file_layout)

        # Buttons
        button_layout = QHBoxLayout()

        self.connect_button = QPushButton("Connect PS4 Controller")
        self.connect_button.clicked.connect(self.toggle_connect)
        button_layout.addWidget(self.connect_button)

        self.play_button = QPushButton("Play MP3")
        self.play_button.clicked.connect(self.play_mp3)
        self.play_button.setEnabled(False)
        button_layout.addWidget(self.play_button)

        layout.addLayout(button_layout)

        # Recording buttons
        record_layout = QHBoxLayout()

        self.record_button = QPushButton("Record (Normal)")
        self.record_button.clicked.connect(lambda: self.record_animation(1.0))
        self.record_button.setEnabled(False)
        record_layout.addWidget(self.record_button)

        self.record_half_button = QPushButton("Record (1/2 Speed)")
        self.record_half_button.clicked.connect(lambda: self.record_animation(0.5))
        self.record_half_button.setEnabled(False)
        record_layout.addWidget(self.record_half_button)

        self.record_quarter_button = QPushButton("Record (1/4 Speed)")
        self.record_quarter_button.clicked.connect(lambda: self.record_animation(0.25))
        self.record_quarter_button.setEnabled(False)
        record_layout.addWidget(self.record_quarter_button)

        layout.addLayout(record_layout)

        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        layout.addWidget(self.progress_bar)

        # Status
        self.status_label = QLabel("Select an MP3 file to begin")
        layout.addWidget(self.status_label)

        self.setLayout(layout)

        # Initialize pygame mixer
        pygame.mixer.init()

    def close_connections(self):
        """Close all connections to ensure other components can use them"""
        try:
            # Stop any recording in progress
            if self.recording:
                self.finish_recording()

            # Release any socket we might be using
            release_udp_socket("RecordingWindow")

            # Clean up subscriber
            if self.subscriber:
                try:
                    self.subscriber.end()
                    time.sleep(0.2)  # Give it time to clean up
                    self.subscriber = None
                except Exception as e:
                    print(f"Error cleaning up subscriber: {e}")

            self.is_connected = False
            return True
        except Exception as e:
            print(f"Error closing connections: {e}")
            return False

    def browse_mp3(self):
        file_dialog = QFileDialog()
        mp3_path, _ = file_dialog.getOpenFileName(
            self, "Select MP3 File", "", "MP3 Files (*.mp3)"
        )

        if mp3_path:
            self.mp3_file_path = mp3_path
            self.file_label.setText(f"File: {os.path.basename(mp3_path)}")

            # Enable all playback and recording buttons
            self.play_button.setEnabled(True)
            self.record_button.setEnabled(True)
            self.record_half_button.setEnabled(True)
            self.record_quarter_button.setEnabled(True)

            # Determine output directory
            base_name = os.path.splitext(os.path.basename(mp3_path))[0]
            self.output_dir = os.path.join("/Users/naddy/Source/Puppet/puppetnet-loader/inputs", base_name)

            self.status_label.setText(f"Ready to use {base_name}")

    def toggle_connect(self):
        if not self.is_connected:
            # Start PS4 controller connection
            self.subscriber = LoggingJoystickSubscriber()
            self.subscriber.start()
            self.is_connected = True
            self.connect_button.setText("Disconnect Controller")
            self.status_label.setText("PS4 Controller connected. Move R3 to control puppet.")
        else:
            # Disconnect
            if self.subscriber:
                self.subscriber.end()
                self.subscriber = None
            self.is_connected = False
            self.connect_button.setText("Connect PS4 Controller")
            self.status_label.setText("PS4 Controller disconnected")

    def play_mp3(self):
        if not self.mp3_file_path:
            return

        pygame.mixer.music.load(self.mp3_file_path)
        pygame.mixer.music.play()

        # Update status
        self.status_label.setText(f"Playing {os.path.basename(self.mp3_file_path)}")

        # Reset status when playback ends
        def check_music_end():
            if not pygame.mixer.music.get_busy():
                self.status_label.setText("Playback finished")
                return
            QTimer.singleShot(100, check_music_end)

        check_music_end()

    def start_countdown(self, speed=1.0):
        """Start a 3-2-1 countdown before recording"""
        # Update the UI to show countdown starting
        self.status_label.setText("Get ready... 3")
        self.repaint()

        # Disable all buttons during countdown
        self.connect_button.setEnabled(False)
        self.play_button.setEnabled(False)
        self.record_button.setEnabled(False)
        self.record_half_button.setEnabled(False)
        self.record_quarter_button.setEnabled(False)
        self.browse_button.setEnabled(False)

        # Create countdown sequence
        self.countdown_value = 3

        # Create countdown timer
        self.countdown_timer = QTimer()
        self.countdown_timer.setInterval(1000)  # 1 second interval

        def update_countdown():
            self.countdown_value -= 1
            if self.countdown_value > 0:
                # Continue countdown
                self.status_label.setText(f"Get ready... {self.countdown_value}")
            else:
                # Stop countdown and start recording
                self.countdown_timer.stop()
                self.status_label.setText("Go!")
                # Give a short pause after "Go!" before starting
                QTimer.singleShot(500, lambda: self._start_recording(speed))

        self.countdown_timer.timeout.connect(update_countdown)
        self.countdown_timer.start()

    def record_animation(self, speed=1.0):
        """Record animation with the given playback speed (1.0 = normal, 0.5 = half speed, etc.)"""
        if not self.mp3_file_path or self.recording:
            return

        # Start the countdown first
        self.start_countdown(speed)

    def _start_recording(self, speed=1.0):
        """Start recording after countdown completes"""
        if not self.mp3_file_path or self.recording:
            return

        # Store the speed for processing later
        self.recording_speed = speed

        # Make sure any previous recording is completely stopped
        if hasattr(self, 'progress_timer') and self.progress_timer.isActive():
            self.progress_timer.stop()

        # Update UI to show we're preparing
        self.status_label.setText("Preparing recording...")
        self.repaint()

        # Ensure we're not still in a recording state
        self.recording = False

        # Completely clean up any existing subscriber
        if self.subscriber:
            try:
                self.subscriber.end()
                # Give it time to clean up
                time.sleep(0.2)
                self.subscriber = None
            except Exception as e:
                print(f"Error cleaning up previous subscriber: {e}")

        # Lock the socket service for our exclusive use during recording
        service = SocketService.get_instance()
        service.lock_service("RecordingWindow")

        # Reset recording state
        self.recorded_data = []
        self.recording = True

        # Create a fresh subscriber after a brief delay
        time.sleep(0.2)  # Give system time to clean up resources

        try:
            # Reset pygame mixer to avoid potential conflicts
            pygame.mixer.quit()
            time.sleep(0.1)
            pygame.mixer.init()

            # Create new subscriber
            self.subscriber = QueueingJoystickSubscriber()
            self.subscriber.start()
            self.is_connected = True
        except Exception as e:
            print(f"Error creating subscriber: {e}")
            self.status_label.setText(f"Error: {str(e)}")
            self.recording = False
            return

        # Make a temporary copy of the mp3 file if we're using a different speed
        self.temp_mp3_path = None

        if speed != 1.0:
            # Create a temporary directory if it doesn't exist
            os.makedirs("/tmp/puppetnet", exist_ok=True)

            # Create a temporary slowed-down version of the MP3
            self.temp_mp3_path = f"/tmp/puppetnet/temp_recording_{speed}.mp3"

            # Use sox to create a slowed down version
            subprocess.run(["sox", self.mp3_file_path, self.temp_mp3_path, "tempo", f"{speed}"])

            # Load the slowed-down version
            pygame.mixer.music.load(self.temp_mp3_path)

            # Get duration of the slowed-down MP3
            sound = pygame.mixer.Sound(self.temp_mp3_path)
            duration = sound.get_length()

            self.status_label.setText(f"Recording at {speed:.2f}x speed...")
        else:
            # Start normal playback
            pygame.mixer.music.load(self.mp3_file_path)

            # Get duration of the MP3
            sound = pygame.mixer.Sound(self.mp3_file_path)
            duration = sound.get_length()

        # Show progress bar
        self.progress_bar.setVisible(True)
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)

        # Update button states
        self.connect_button.setText("Recording in progress...")
        self.connect_button.setEnabled(False)
        self.play_button.setEnabled(False)
        self.record_button.setEnabled(False)
        self.record_half_button.setEnabled(False)
        self.record_quarter_button.setEnabled(False)
        self.browse_button.setEnabled(False)

        # Play the MP3
        pygame.mixer.music.play()
        if speed != 1.0:
            self.status_label.setText(f"Recording at {speed:.2f}x speed... Move the right stick (R3) to control puppet!")
        else:
            self.status_label.setText("Recording animation... Move the right stick (R3) to control puppet!")

        # Update progress
        start_time = time.time()

        # Create a timer that checks if recording is complete
        self.progress_timer = QTimer()
        self.progress_timer.setInterval(100)  # 100ms

        def check_progress():
            if not pygame.mixer.music.get_busy():
                # Recording finished
                self.progress_timer.stop()
                # Use QTimer.singleShot to ensure we're on the main thread for UI updates
                QTimer.singleShot(200, self.finish_recording)
                return

            elapsed = time.time() - start_time
            progress = min(100, int(elapsed / duration * 100))
            self.progress_bar.setValue(progress)

        self.progress_timer.timeout.connect(check_progress)
        self.progress_timer.start()

        # Also set a backup timer to ensure recording stops after duration + 0.5 seconds
        QTimer.singleShot(int((duration + 0.5) * 1000), lambda: self.finish_recording() if self.recording else None)

    def finish_recording(self):
        """Safely finish the recording process"""
        # Only proceed if we're actually recording
        if not self.recording:
            return

        # Set recording flag to false immediately to prevent multiple calls
        self.recording = False

        # Immediately capture data to avoid any thread issues
        # We'll copy the data now rather than waiting for thread cleanup
        if self.subscriber and hasattr(self.subscriber, 'data_points'):
            try:
                # Make a clean copy of the data before doing anything else
                with self.subscriber.queue_lock:
                    self.recorded_data = self.subscriber.data_points.copy()
                print(f"Successfully captured {len(self.recorded_data)} data points")
            except Exception as e:
                print(f"Error capturing data: {e}")

        # Stop pygame music playback if it's still going
        try:
            if pygame.mixer.music.get_busy():
                pygame.mixer.music.stop()
        except Exception as e:
            print(f"Error stopping pygame music: {e}")

        # Stop the progress timer if it exists
        if hasattr(self, 'progress_timer'):
            try:
                if self.progress_timer.isActive():
                    self.progress_timer.stop()
            except Exception as e:
                print(f"Error stopping timer: {e}")

        # Update UI immediately to show we're processing
        self.status_label.setText("Processing recording...")

        print("A")
        self.progress_bar.setValue(100)
        self.status_label.setText("Processing recording...B")
        print("B")
        self.repaint()  # Force immediate repaint

        print("C")
        self.status_label.setText("Processing recording...C")

        # CRITICAL: Now we'll complete without doing any resource cleanup or complex thread operations
        # This avoids any potential blocking. We'll re-enable everything immediately.

        # Re-enable all buttons
        self._reactivate_buttons()
        print("D")
        self.status_label.setText("Processing recording...D")
        # Just schedule a very minimal callback to emit the signal with data
        QTimer.singleShot(10, lambda: self._minimal_process_recording())
        self.status_label.setText("Processing recording...")

    def _minimal_process_recording(self):
        """Process recording data with minimal operations to avoid blocking"""
        try:
            # If we have data, handle speed adjustments
            if self.recorded_data:
                # Handle speed adjustment if needed
                if hasattr(self, 'recording_speed') and self.recording_speed != 1.0:
                    speed = self.recording_speed

                    # Calculate target frames
                    target_frames = int(len(self.recorded_data) * speed)

                    if target_frames > 0:
                        # Simple interpolation
                        indices = np.linspace(0, len(self.recorded_data) - 1, target_frames)
                        interpolated_data = [self.recorded_data[int(i)] for i in indices]
                        self.recorded_data = interpolated_data

                # Update status
                self.status_label.setText(f"Recording complete! Captured {len(self.recorded_data)} data points")

                # Send data to main window
                self.signals.recording_complete.emit(self.recorded_data)

                # Save the recording to a fixed location
                self.save_to_fixed_location()
            else:
                self.status_label.setText("Recording complete, but no data was captured")

            # Hide progress bar
            self.progress_bar.setVisible(False)

            # Schedule socket and thread cleanup for later, when it's safe
            threading.Thread(target=self._delayed_cleanup, daemon=True).start()
        except Exception as e:
            print(f"Error in minimal processing: {e}")
            self.status_label.setText("Error processing recording")
            self.progress_bar.setVisible(False)

    def _delayed_cleanup(self):
        """Run cleanup operations in a separate thread after a delay"""
        try:
            # Wait a bit before cleanup
            time.sleep(2.0)

            # Reset mixer
            try:
                pygame.mixer.quit()
                time.sleep(0.2)
                pygame.mixer.init()
            except:
                pass

            # Unlock the socket service
            service = SocketService.get_instance()
            service.unlock_service("RecordingWindow")

            # Clean up subscriber
            if self.subscriber:
                try:
                    old_sub = self.subscriber
                    self.subscriber = None
                    old_sub.end()
                    time.sleep(0.5)
                except:
                    pass

            # Create a new fresh subscriber
            try:
                self.subscriber = LoggingJoystickSubscriber()
                self.subscriber.start()
                self.is_connected = True
            except:
                self.is_connected = False

            print("Delayed cleanup complete")
        except Exception as e:
            print(f"Error in delayed cleanup: {e}")

    def _process_recording_data(self):
        """Process the recorded data - runs after UI has updated"""
        try:
            # Get the recorded data from the subscriber
            if self.subscriber:
                # Use the correct method name to get the recorded data
                self.recorded_data = self.subscriber.get_recorded_data() if hasattr(self.subscriber, 'get_recorded_data') else []

                # Process data if we used a different speed
                if hasattr(self, 'recording_speed') and self.recording_speed != 1.0:
                    # When recording at slower speeds, we need to interpolate the data to match normal speed
                    speed = self.recording_speed

                    # Determine the target number of frames at normal speed
                    # For example, at half speed (0.5), we recorded twice as many frames as needed
                    target_frames = int(len(self.recorded_data) * speed)

                    if target_frames > 0:
                        # Use linear interpolation to reduce the number of frames
                        indices = np.linspace(0, len(self.recorded_data) - 1, target_frames)
                        interpolated_data = [self.recorded_data[int(i)] for i in indices]

                        # Log information about the conversion
                        print(f"Converting recorded data from {self.recording_speed}x speed: "
                              f"{len(self.recorded_data)} frames â†’ {len(interpolated_data)} frames")

                        # Replace the recorded data with the interpolated data
                        self.recorded_data = interpolated_data

                        self.status_label.setText(
                            f"Recording complete! Converted {len(self.recorded_data)} data points to normal speed."
                        )
                    else:
                        self.status_label.setText("Not enough data to convert to normal speed.")

                    # Clean up temporary files
                    if hasattr(self, 'temp_mp3_path') and self.temp_mp3_path:
                        try:
                            if os.path.exists(self.temp_mp3_path):
                                os.remove(self.temp_mp3_path)
                        except Exception as e:
                            print(f"Error removing temporary file: {e}")

                # We create a new subscriber for manual control
                # This ensures we have a clean subscriber state
                try:
                    if self.subscriber:
                        self.subscriber.end()
                        self.subscriber = None

                    # Small delay to ensure cleanup
                    time.sleep(0.1)

                    # Create a fresh subscriber for manual control
                    self.subscriber = LoggingJoystickSubscriber()
                    self.subscriber.start()
                    self.is_connected = True
                    self.connect_button.setText("Disconnect Controller")
                    self.connect_button.setEnabled(True)
                except Exception as e:
                    print(f"Error recreating subscriber: {e}")
                    self.connect_button.setText("Connect PS4 Controller")
                    self.connect_button.setEnabled(True)
                    self.is_connected = False

            # Re-enable buttons with a slight delay to avoid UI collisions
            QTimer.singleShot(100, lambda: self._reactivate_buttons())

            # Save recorded data
            if self.recorded_data:
                if not hasattr(self, 'recording_speed') or self.recording_speed == 1.0:
                    self.status_label.setText(f"Recording complete! Captured {len(self.recorded_data)} data points")

                # Emit signal with recorded data
                self.signals.recording_complete.emit(self.recorded_data)

                # Save recording to fixed location to avoid prompts
                QTimer.singleShot(100, self.save_to_fixed_location)
            else:
                self.status_label.setText("Recording complete, but no data was captured")

            self.progress_bar.setVisible(False)
        except Exception as e:
            print(f"Error processing recording data: {e}")
            self.status_label.setText(f"Error processing recording: {str(e)}")
            self.progress_bar.setVisible(False)
            self._reactivate_buttons()  # Use the helper method for consistency

    def save_to_fixed_location(self):
        """Save to a fixed location (nja_test) to avoid any interactive prompts"""
        if not self.recorded_data:
            return

        try:
            # Create directory if needed
            os.makedirs(NJA_DIR, exist_ok=True)

            # Copy MP3 file - use the source file if available
            if self.mp3_file_path:
                # Copy the selected MP3 to the fixed location
                shutil.copy2(self.mp3_file_path, NJA_MP3)

                # Generate WAV using ffmpeg with -y to force overwrite
                subprocess.run(["ffmpeg", "-y", "-i", NJA_MP3, NJA_WAV],
                               stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                
                # Update the global current MP3
                global CURRENT_MP3
                CURRENT_MP3 = self.mp3_file_path

            # Create JSON content
            output = {}
            output["servos"] = {"servo_0": {"pin": 0}}

            # Create animation history
            output["history"] = [
                {"frame": frame, "servos": {"servo_0": {"triangle": 0.0, "servo": int(val)}}}
                for frame, val in enumerate(self.recorded_data, 1)
            ]

            # Write JSON file
            with open(NJA_JSON, 'w') as outf:
                outf.write(json.dumps(output))
                
            # Update the global current JSON
            global CURRENT_JSON
            CURRENT_JSON = NJA_JSON

            self.status_label.setText(f"Saved recording to {NJA_DIR}")
            print(f"Successfully saved animation to {NJA_DIR}")
        except Exception as e:
            print(f"Error saving to fixed location: {e}")
            self.status_label.setText("Error saving recording")

    def save_recording(self):
        """Original save method (not used anymore)"""
        if not self.mp3_file_path or not self.recorded_data:
            return

        # Create output directory if it doesn't exist
        os.makedirs(self.output_dir, exist_ok=True)

        # Copy MP3 file
        mp3_filename = os.path.basename(self.mp3_file_path)
        output_mp3_path = os.path.join(self.output_dir, mp3_filename)
        shutil.copy2(self.mp3_file_path, output_mp3_path)

        # Generate WAV version if needed
        output_wav_path = os.path.join(self.output_dir, os.path.splitext(mp3_filename)[0] + ".wav")
        subprocess.run(["ffmpeg", "-i", output_mp3_path, output_wav_path])

        # Create JSON file
        base_name = os.path.splitext(os.path.basename(self.mp3_file_path))[0]
        output_json_path = os.path.join(self.output_dir, f"{base_name}.json")

        # Create JSON content
        output = {}
        output["servos"] = {"servo_0": {"pin": 0}}

        # Create animation history
        output["history"] = [
            {"frame": frame, "servos": {"servo_0": {"triangle": 0.0, "servo": int(val)}}}
            for frame, val in enumerate(self.recorded_data, 1)
        ]

        # Write JSON file
        with open(output_json_path, 'w') as outf:
            outf.write(json.dumps(output))

        self.status_label.setText(f"Saved recording to {self.output_dir}")

    def _reactivate_buttons(self):
        """Helper method to consistently re-enable all buttons"""
        # Enable all buttons based on current state
        self.play_button.setEnabled(bool(self.mp3_file_path))
        self.record_button.setEnabled(bool(self.mp3_file_path))
        self.record_half_button.setEnabled(bool(self.mp3_file_path))
        self.record_quarter_button.setEnabled(bool(self.mp3_file_path))
        self.browse_button.setEnabled(True)
        self.connect_button.setEnabled(True)

# Main Animation Editor Window from minimal_example
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Animation Editor")

        # Use the existing MplGraphCanvas from minimal_example
        self.canvas = MplGraphCanvas(self)
        self.canvas.setFocusPolicy(Qt.StrongFocus)
        self.canvas.setFocus()

        self.canvas.keyPressEvent = self.canvas.key_press_event
        self.canvas.keyReleaseEvent = self.canvas.key_release_event

        self.save_button = QPushButton("Save")
        self.save_button.clicked.connect(self.canvas.upload_and_play_program)

        self.load_button = QPushButton("Load")
        self.load_button.clicked.connect(self.load_from_csv)

        # New button for recording animation
        self.record_animation_button = QPushButton("Record New Animation")
        self.record_animation_button.clicked.connect(self.open_recording_window)

        layout = QVBoxLayout()
        layout.addWidget(self.canvas)

        # Add mode toggle button
        self.toggle_button = QPushButton("Switch to Select Mode")
        self.toggle_button.clicked.connect(self.toggle_mode)
        layout.addWidget(self.toggle_button)

        # Main button layout
        button_layout = QHBoxLayout()
        button_layout.addWidget(self.load_button)
        button_layout.addWidget(self.save_button)
        button_layout.addWidget(self.record_animation_button)
        layout.addLayout(button_layout)

        # Add playback speed buttons
        playback_layout = QHBoxLayout()

        self.play_normal_button = QPushButton("Play")
        self.play_normal_button.clicked.connect(lambda: self.upload_and_play_nja_test(1.0))
        playback_layout.addWidget(self.play_normal_button)

        self.play_half_button = QPushButton("Play 1/2")
        self.play_half_button.clicked.connect(lambda: self.upload_and_play_nja_test(0.5))
        playback_layout.addWidget(self.play_half_button)

        self.play_quarter_button = QPushButton("Play 1/4")
        self.play_quarter_button.clicked.connect(lambda: self.upload_and_play_nja_test(0.25))
        playback_layout.addWidget(self.play_quarter_button)

        layout.addLayout(playback_layout)

        container = QWidget()
        container.setLayout(layout)
        self.setCentralWidget(container)
        
        # Start with a blank animation instead of loading a file
        self._create_blank_animation()

    def toggle_mode(self):
        if self.canvas.mode == "click":
            self.canvas.mode = "select"
            self.toggle_button.setText("Switch to Click Mode")
            self.canvas.selector.set_active(True)
        else:
            self.canvas.mode = "click"
            self.toggle_button.setText("Switch to Select Mode")
            self.canvas.selector.set_active(False)

    def load_file(self, fname):
        """Load animation data from JSON file and corresponding audio"""
        try:
            # Load JSON data
            with open(fname, 'r') as f:
                data = json.loads(f.read())
                
            # Get the first servo name in the file
            servo_name = list(data["servos"].keys())[0]
            
            # Extract frames and values
            frames = [d['frame'] for d in data["history"]]
            frames = [int(x) - 1 for x in frames]
            values = [d["servos"][servo_name]["servo"] for d in data["history"]]
            
            # Update the canvas with the loaded data
            self.canvas.curve.x = frames
            self.canvas.curve.y = values
            self.canvas.line.set_data(self.canvas.curve.x, self.canvas.curve.y)
            self.update_view()
            
            self.canvas.control_indices = []
            self.canvas.update_control_display()
            self.canvas.draw_idle()
            self.canvas.set_draggable_points()
            
            # Update global current file paths
            global CURRENT_JSON, CURRENT_MP3
            CURRENT_JSON = fname
            
            # Find the corresponding MP3 file
            json_dir = os.path.dirname(fname)
            base_name = os.path.splitext(os.path.basename(fname))[0]
            mp3_path = os.path.join(json_dir, f"{base_name}.mp3")
            
            if os.path.exists(mp3_path):
                CURRENT_MP3 = mp3_path
                
                # Copy to nja_test for immediate playback
                self.canvas._save_to_nja_test()
                
                print(f"Loaded animation from {fname} with audio {mp3_path}")
            else:
                print(f"Loaded animation from {fname} but no corresponding MP3 found")
                
            return True
        except Exception as e:
            print(f"Error loading file: {e}")
            return False

    def update_view(self):
        self.canvas.update_view()
        return

    def load_from_csv(self):
        """Let user select a JSON file to load"""
        file_dialog = QFileDialog()
        json_path, _ = file_dialog.getOpenFileName(
            self, "Select Animation JSON File", "", "JSON Files (*.json)"
        )
        
        if json_path:
            self.load_file(json_path)
        return

    def upload_and_play_nja_test(self, tempo=1.0):
        """Upload and play the animation from the fixed nja_test location with specified tempo"""
        # First, close any connections from the recording window if it exists
        if hasattr(self, 'recording_window') and self.recording_window:
            self.recording_window.close_connections()

        # Make sure no other component is using the socket service
        service = SocketService.get_instance()
        service.unlock_service("force")  # Force unlock in case something is holding it

        # Create the output directory if it doesn't exist
        os.makedirs(NJA_OUTPUT_DIR, exist_ok=True)

        # Save the current animation to the nja_test directory
        self.canvas._save_to_nja_test()

        # Ensure the files exist
        if not os.path.exists(NJA_JSON) or not os.path.exists(NJA_MP3):
            print(f"Error: Required files not found in {NJA_DIR}")
            return

        print(f"Playing nja_test at {tempo}x speed")

        # Create animation JSON with tempo applied
        output = {}
        output["servos"] = {"servo_0": {"pin": 0}}

        output["history"] = [
            {"frame": frame * 1/tempo, "servos": {"servo_0": {"triangle": 0.0, "servo": int(val)}}}
            for frame, val in enumerate(self.canvas.curve.y, 1)
        ]

        # Write the JSON file with tempo adjustments
        with open(NJA_JSON, 'w') as outf:
            outf.write(json.dumps(output))

        # Compile the animation
        time.sleep(.5)
        subprocess.run(["./bin/compile-animation", NJA_JSON, NJA_MP3, NJA_OUTPUT_DIR,
                        "--force", "--frame-rate", str(self.canvas.fps)])

        # Apply tempo if needed
        if tempo != 1.0:
            name = os.path.join(NJA_OUTPUT_DIR, os.path.basename(NJA_MP3))
            backup = name + ".bak"
            new_file = name + ".new.mp3"

            # Make a backup
            shutil.copy2(name, backup)

            # Apply tempo change
            result = subprocess.run(["sox", name, new_file, "tempo", f"{tempo}"])

            # Replace the original
            shutil.copy2(new_file, name)
            os.remove(new_file)
            time.sleep(1.0)

        # Upload the program
        subprocess.run(["bin/upload-program", NJA_OUTPUT_DIR])
        time.sleep(1.0)

        # Use the dev_cmd tool to play, which avoids socket conflicts
        try:
            print(f"Running: ./bin/dev_cmd PUPPET_01 play {NJA_NAME}")
            subprocess.run(["./bin/dev_cmd", "PUPPET_01", "play", NJA_NAME])
        except Exception as e:
            print(f"Error playing animation: {e}")

        return

    def _create_blank_animation(self):
        """Create a blank animation with a default flat line"""
        # Create a simple flat line at neutral position
        frames = list(range(50))  # 50 frames
        values = [7000] * 50      # Neutral position at 7000
        
        # Update the canvas
        self.canvas.curve.x = frames
        self.canvas.curve.y = values
        self.canvas.line.set_data(self.canvas.curve.x, self.canvas.curve.y)
        self.update_view()
        
        self.canvas.control_indices = []
        self.canvas.update_control_display()
        self.canvas.draw_idle()
        self.canvas.set_draggable_points()
        
        # Reset the current file paths
        global CURRENT_JSON, CURRENT_MP3
        CURRENT_JSON = None
        CURRENT_MP3 = None
        
        print("Created new blank animation")
    
    def open_recording_window(self):
        # Create and show the recording window
        self.recording_window = RecordingWindow(self)

        # Connect signal to handle recorded data
        self.recording_window.signals.recording_complete.connect(self.process_recorded_data)

        self.recording_window.exec()

    def process_recorded_data(self, data):
        if not data:
            return

        # Update the curve with the recorded data
        frames = list(range(len(data)))
        values = data

        self.canvas.curve.x = frames
        self.canvas.curve.y = values
        self.canvas.line.set_data(self.canvas.curve.x, self.canvas.curve.y)
        self.update_view()

        self.canvas.control_indices = []
        self.canvas.update_control_display()
        self.canvas.draw_idle()
        self.canvas.set_draggable_points()

# Include the necessary classes from minimal_example
def unpacker(f):
    def alt_f(self, **kwds):
        d = f(self, **kwds)
        return tuple(d[k] for k in kwds)
    return alt_f

class HistoryManager:
    def __init__(self):
        self.history_ptr = -1
        self.history_states = []

    def record_history(self, **kwds):
        # Trim future states if we're in the middle
        if self.history_ptr < len(self.history_states) - 1:
            self.history_states = self.history_states[:self.history_ptr + 1]

        # Append a deepcopy of the current state
        self.history_states.append(copy.deepcopy(kwds))
        self.history_ptr += 1

    @unpacker
    def undo(self, **kwds):
        if self.history_ptr <= 0:
            return kwds

        self.history_ptr -= 1
        past_state = self.history_states[self.history_ptr]
        return {k: past_state.get(k, kwds[k]) for k in kwds}

    @unpacker
    def redo(self, **kwds):
        if self.history_ptr >= len(self.history_states) - 1:
            return kwds  # Nothing to redo

        self.history_ptr += 1
        future_state = self.history_states[self.history_ptr]
        return {k: future_state.get(k, kwds[k]) for k in kwds}

class PlottedCurve:
    def __init__(self, x=None, y=None):
        self._x = np.array(x) if x is not None else np.array([])
        self._y = np.array(y) if y is not None else np.array([])

    @property
    def x(self):
        return self._x

    @x.setter
    def x(self, new_x):
        self._x = np.array(new_x)

    @property
    def y(self):
        return self._y

    @y.setter
    def y(self, new_y):
        self._y = np.array(new_y)

    def get_data(self):
        return self._x, self._y

    def set_data(self, x, y):
        self._x = np.array(x)
        self._y = np.array(y)

    def __len__(self):
        return len(self._x)

class MplGraphCanvas(FigureCanvas):
    def __init__(self, parent=None):
        self.fps = 24
        self.mode = "click"
        self.shift_down = False
        self.ctrl_down = False
        self.meta_down = False
        self.alt_down = False

        self.undo_manager = HistoryManager()

        self.fig = Figure()
        super().__init__(self.fig)
        self.ax = self.fig.add_subplot(111)

        self.ax.axhline(8000, color='lightgrey', linewidth=1, linestyle='--', zorder=0)
        self.ax.axhline(5900, color='lightgrey', linewidth=1, linestyle='--', zorder=0)

        self.curve = PlottedCurve(np.linspace(0, 10, 100), np.sin(np.linspace(0, 10, 100)))
        self.line, = self.ax.plot(self.curve.x, self.curve.y, color='dimgray', linestyle='-')

        self.last_drag_y = None
        self.setParent(parent)

        self.selected_indices = []
        self.last_selected_indices = []
        self.range_indices = []

        self.selector = RectangleSelector(
            self.ax,
            onselect=self.on_select,
            useblit=True,
            button=[1],
            minspanx=5, minspany=5,
            spancoords='pixels'
        )
        self.selector.set_active(False)

        self.control_scatter = self.ax.scatter([], [], color='red', zorder=5)
        self.set_draggable_points()

        self.dragging = None

        self.mpl_connect("button_press_event", self.on_click)
        self.mpl_connect("motion_notify_event", self.on_drag)
        self.mpl_connect("button_release_event", self.on_release)

        return

    def record_history(self):
        return self.undo_manager.record_history(
            curve=self.curve,
            selected=self.selected_indices,
            fps=self.fps,
        )

    def undo(self):
        (self.curve, self.selected_indices, self.fps) = (
            self.undo_manager.undo(curve=self.curve, selected=self.selected_indices, fps=self.fps)
        )
        return None

    def redo(self):
        (self.curve, self.selected_indices, self.fps) = (
            self.undo_manager.redo(curve=self.curve, selected=self.selected_indices, fps=self.fps)
        )
        return

    def insert_point_at_start(self):
        # Get current curve data
        self.record_history()

        xx = [0] + [(n+1) for n in self.curve.x]
        yy = [self.curve.y[0]] + self.curve.y.tolist()

        self.curve.set_data(xx, yy)
        self.selected_indices = [(n+1) for n in self.selected_indices]

        self.highlight_selected()

        self.update_curve()
        self.draw_idle()
        self.setFocus()
        self.update_view()

        return

    def delete_point_at_start(self):
        # Get current curve data
        self.record_history()

        xx = [(n-1) for n in self.curve.x[1:]]
        yy = self.curve.y.tolist()[1:]

        self.curve.set_data(xx, yy)
        self.selected_indices = [(n-1) for n in self.selected_indices]

        self.highlight_selected()

        self.update_curve()
        self.draw_idle()
        self.setFocus()
        self.update_view()

        return

    def update_view(self):
        self.ax.relim()
        self.ax.autoscale_view(scalex=True, scaley=False)
        self.ax.set_ylim(4000, 8300)
        return

    def key_press_event(self, event):
        if event.key() == Qt.Key_Shift:
            self.shift_down = True
        if event.key() == Qt.Key_Control:
            self.control_down = True
        if event.key() == Qt.Key_Meta:
            self.meta_down = True
        if event.key() == Qt.Key_Alt:
            self.alt_down = True

        text = event.text().lower()
        print(text)

        if text == 's' and self.mode != "select":
            self.mode = "select"
            self.selector.set_active(True)
        elif text == 'q':
            self.undo()
            self.update_curve()
            self.draw_idle()
            self.setFocus()
            self.update_view()
        elif text == 'e':
            self.redo()
            self.update_curve()
            self.draw_idle()
            self.setFocus()
            self.update_view()
        elif text == 'x':
            if not self.selected_indices and self.last_selected_indices:
                self.selected_indices = self.last_selected_indices
            else:
                self.last_selected_indices = self.selected_indices
                self.selected_indices = []
            self.highlight_selected()
        elif text == 'i':
            if not self.shift_down:
                self.insert_point_at_start()
            else:
                self.delete_point_at_start()

        elif text == '1':
            # Close any recorder connections through the parent
            if hasattr(self, 'parent') and self.parent() and hasattr(self.parent(), 'recording_window'):
                if self.parent().recording_window:
                    self.parent().recording_window.close_connections()
            
            # Unlock the socket service
            service = SocketService.get_instance()
            service.unlock_service("force")
            
            # Save the current state to nja_test before playing
            self._save_to_nja_test()
            
            self.upload_and_play_program(tempo=1.0)
        elif text == '2':
            # Close any recorder connections through the parent
            if hasattr(self, 'parent') and self.parent() and hasattr(self.parent(), 'recording_window'):
                if self.parent().recording_window:
                    self.parent().recording_window.close_connections()
            
            # Unlock the socket service
            service = SocketService.get_instance()
            service.unlock_service("force")
            
            # Save the current state to nja_test before playing
            self._save_to_nja_test()
            
            self.upload_and_play_program(tempo=.5)
        elif text == '3':
            # Close any recorder connections through the parent
            if hasattr(self, 'parent') and self.parent() and hasattr(self.parent(), 'recording_window'):
                if self.parent().recording_window:
                    self.parent().recording_window.close_connections()
            
            # Unlock the socket service
            service = SocketService.get_instance()
            service.unlock_service("force")
            
            # Save the current state to nja_test before playing
            self._save_to_nja_test()
            
            self.upload_and_play_program(tempo=.25)

        elif text == '+':
            # Double Resolution
            xx, yy = double_resolution(self.curve.x, self.curve.y)
            self.record_history()
            self.fps *= 2
            self.curve.set_data(xx, yy)
            self.selected_indices = []
            self.highlight_selected()

            self.update_curve()
            self.draw_idle()
            self.setFocus()
            self.update_view()

        elif text == 'p':
            # Close any recorder connections through the parent
            if hasattr(self, 'parent') and self.parent() and hasattr(self.parent(), 'recording_window'):
                if self.parent().recording_window:
                    self.parent().recording_window.close_connections()
            
            # Unlock the socket service
            service = SocketService.get_instance()
            service.unlock_service("force")
            
            xx = self.curve.x.tolist()
            yy = self.curve.y.tolist()

            if not self.shift_down:
                xx = [xx[ndx] for ndx in self.selected_indices]
                yy = [yy[ndx] for ndx in self.selected_indices]

            # Save the current state to nja_test before playing
            self._save_to_nja_test()
                
            play_on_puppet(xx, yy, self.fps)
        return

    def key_release_event(self, event):
        if event.key() == Qt.Key_Shift:
            self.shift_down = False
        if event.key() == Qt.Key_Control:
            self.control_down = False
        if event.key() == Qt.Key_Meta:
            self.meta_down = False
        if event.key() == Qt.Key_Alt:
            self.alt_down = False

        text = event.text().lower()
        if text == 's' and self.mode == "select":
            self.mode = "click"
            self.selector.set_active(False)
        return

    def update_curve(self):
        self.line.set_data(self.curve.x, self.curve.y)
        self.ax.relim()
        self.ax.autoscale_view(scalex=True, scaley=False)
        self.ax.set_ylim(5000, 8000)
        self.update_control_display()
        self.draw_idle()

    def set_draggable_points(self):
        if hasattr(self, 'control_scatter'):
            self.control_scatter.remove()
        self.control_scatter = self.ax.scatter(self.curve.x, self.curve.y, color='black', marker='x', zorder=5)
        self.draw_idle()
        return

    def on_select(self, eclick, erelease):
        if self.mode != "select":
            return

        x0, x1 = sorted([eclick.xdata, erelease.xdata])
        y0, y1 = sorted([eclick.ydata, erelease.ydata])

        if self.shift_down:
            for i in range(len(self.curve.x)):
                x, y = self.curve.x[i], self.curve.y[i]
                if x0 <= x <= x1 and y0 <= y <= y1:
                    if i in self.selected_indices:
                        self.selected_indices.remove(i)
                    else:
                        self.selected_indices.append(i)
        else:
            self.selected_indices = []
            for i in range(len(self.curve.x)):
                x, y = self.curve.x[i], self.curve.y[i]
                if x0 <= x <= x1 and y0 <= y <= y1:
                    self.selected_indices.append(i)

        self.highlight_selected()
        return

    def highlight_selected(self):
        if not self.selected_indices:
            self.control_scatter.set_facecolors('black')
            self.draw_idle()
            return

        facecolors = ['green' if ndx in self.selected_indices else 'black' for ndx in range(len(self.curve.x))]
        facecolors = ['blue' if ndx in self.range_indices else color for (ndx, color) in enumerate(facecolors)]

        self.control_scatter.set_facecolors(facecolors)
        self.draw_idle()

        return

    def on_click(self, event):
        if self.mode != "click" or event.inaxes != self.ax:
            return

        self.record_history()

        # Selected point
        x_click = event.xdata
        idx = np.argmin(np.abs(self.curve.x - x_click))
        self.dragging = idx
        self.last_drag_y = event.ydata

        # What do we do with it
        if self.shift_down:
            if idx in self.selected_indices:
                self.selected_indices.remove(idx)
            else:
                self.selected_indices.append(idx)
        elif self.ctrl_down:
            if idx in self.range_indices:
                self.range_indices.remove(idx)
            else:
                self.range_indices.append(idx)
                self.range_indices = self.range_indices[-2:]
        else:
            # self.selected_indices = [idx]
            self.undo_pending = True  # record undo once on first drag

        self.highlight_selected()
        self.update_control_display()
        return

    def on_drag(self, event):
        if self.mode == "click":
            # Send signal to puppet
            send_servo(0, event.ydata)

        if self.mode != "click" or self.dragging is None or event.inaxes != self.ax:
            return

        if event.ydata is None or self.last_drag_y is None:
            return

        dy = event.ydata - self.last_drag_y
        self.last_drag_y = event.ydata

        # Fix this NJA
        # Figure out the new curve in advance.
        new_ys = self.curve.y.copy()
        if self.dragging in self.selected_indices:
            for i in self.selected_indices:
                new_y = new_ys[i] + dy
                if not (5000 <= new_y <= 8000):
                    return
                new_ys[i] = new_y
        else:
            new_y = event.ydata
            if not (5000 <= new_y <= 8000):
                return
            new_ys[self.dragging] = new_y


        # Save current state for undo before applying changes
        if getattr(self, "undo_pending", True):
            self.record_history()
            self.undo_pending = False

        self.curve.y = new_ys
        self.line.set_ydata(self.curve.y)
        self.update_control_display()
        self.draw_idle()
        return

    def on_release(self, event):
        if self.mode == "click":
            self.dragging = None
            self.last_drag_y = None

    def update_control_display(self):
        x_vals = self.curve.x[:]
        y_vals = self.curve.y[:]
        self.control_scatter.set_offsets(np.column_stack([x_vals, y_vals]))
        self.draw_idle()
        return
        
    def _save_to_nja_test(self):
        """Save the current animation state to the nja_test directory"""
        try:
            # Create directory if needed
            os.makedirs(NJA_DIR, exist_ok=True)
            
            # Create JSON content
            output = {}
            output["servos"] = {"servo_0": {"pin": 0}}
            
            # Create animation history from current curve
            output["history"] = [
                {"frame": frame, "servos": {"servo_0": {"triangle": 0.0, "servo": int(val)}}}
                for frame, val in enumerate(self.curve.y, 1)
            ]
            
            # Write JSON file
            with open(NJA_JSON, 'w') as outf:
                outf.write(json.dumps(output))
                
            print(f"Saved current animation to {NJA_JSON}")
            
            # Copy the current MP3 file if available
            if CURRENT_MP3 and os.path.exists(CURRENT_MP3):
                shutil.copy2(CURRENT_MP3, NJA_MP3)
                
                # Generate WAV using ffmpeg
                subprocess.run(["ffmpeg", "-y", "-i", NJA_MP3, NJA_WAV],
                              stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                
                print(f"Copied audio from {CURRENT_MP3} to {NJA_MP3}")
            else:
                # If no MP3 is loaded but NJA_MP3 already exists, keep it
                if not os.path.exists(NJA_MP3):
                    print("Warning: No audio file available - playback may not work properly")
                
        except Exception as e:
            print(f"Error saving to nja_test: {e}")

    def upload_and_play_program(self, tempo=1.0):
        # Close any recorder connections through the parent
        if hasattr(self, 'parent') and self.parent() and hasattr(self.parent(), 'recording_window'):
            if self.parent().recording_window:
                self.parent().recording_window.close_connections()
        
        # Unlock the socket service
        service = SocketService.get_instance()
        service.unlock_service("force")
        
        self.save_to_csv(tempo=tempo)

        print(f"TEMPO: {tempo}")

        time.sleep(.5)
        subprocess.run(["./bin/compile-animation", PROGRAM_FILE_2, PROGRAM_AUDIO_2, PROGRAM_DIR_2, "--force", "--frame-rate", str(self.fps)])

        if tempo != 1.0:
            name = PROGRAM_DIR_2 / PROGRAM_AUDIO_2.name
            shutil.copy2(PROGRAM_AUDIO_2, str(PROGRAM_DIR_2 / PROGRAM_AUDIO_2.name) + ".bak")

            result = subprocess.run(["sox", name, str(name) + ".new.mp3", "tempo", f"{tempo}"])
            shutil.copy2(str(name) + ".new.mp3", str(name))
            os.remove(str(name) + ".new.mp3")
            time.sleep(1.0)

        # Upload the program
        subprocess.run(["bin/upload-program", PROGRAM_DIR_2])
        time.sleep(1.0)

        # Play the program using the dev_cmd tool rather than direct socket communication
        try:
            print(f"Running: ./bin/dev_cmd PUPPET_01 play {PROGRAM_NAME}")
            subprocess.run(["./bin/dev_cmd", "PUPPET_01", "play", PROGRAM_NAME])
        except Exception as e:
            print(f"Error playing animation: {e}")

        return

    def save_to_csv(self, tempo=1.0):
        output = {}
        output["servos"] = json.loads(open(PROGRAM_FILE).read())["servos"]
        servo_name = list(json.loads(open(PROGRAM_FILE).read())["servos"].keys())[0]

        output["history"] = [
            {"frame": frame * 1/tempo, "servos": {servo_name: {"triangle": 0.0, "servo": int(val)}}}
            for frame, val in enumerate(self.curve.y, 1)
        ]

        prog_dir = (Path(PROGRAM_FILE).parent.parent / PROGRAM_NAME)
        prog_dir.mkdir(parents=True, exist_ok=True)

        outf_name = (Path(PROGRAM_FILE).parent.parent / PROGRAM_NAME) / (PROGRAM_NAME + ".json")

        with open(outf_name, 'w') as outf:
            outf.write(json.dumps(output))

        output_audio_f = (Path(PROGRAM_FILE).parent.parent / PROGRAM_NAME) / (PROGRAM_NAME + Path(PROGRAM_AUDIO).suffix)

        print(f"Copying {PROGRAM_AUDIO} to {output_audio_f}")
        shutil.copy2(PROGRAM_AUDIO, output_audio_f)
        return

def double_resolution(x, y):
    x = np.asarray(x)
    y = np.asarray(y)

    new_x = np.empty(2 * len(x) - 1, dtype=float)
    new_y = np.empty_like(new_x)

    new_x[::2] = x
    new_x[1::2] = (x[:-1] + x[1:]) / 2

    new_y[::2] = y
    new_y[1::2] = (y[:-1] + y[1:]) / 2  # Linear interpolation

    return list(map(int, (2 * new_x).tolist())), list(map(int, new_y.tolist()))

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.resize(1920, 1080)

    screens = app.screens()

    if len(screens) > 1:
        other_screen = screens[0]  # Index 0 is primary, 1 is usually the second screen
        geometry = other_screen.geometry()
        window.move(geometry.topLeft())

    window.show()
    sys.exit(app.exec())