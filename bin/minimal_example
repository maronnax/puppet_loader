#!/usr/bin/env python3

import sys
import numpy as np
import json
import time
import os
import socket

from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QPushButton, QVBoxLayout, QWidget, QFileDialog
)
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from matplotlib.widgets import RectangleSelector
import pygame

def play_on_puppet(frames, values, fps):
    pygame.mixer.init()
    pygame.mixer.music.load("/Users/naddy/Source/Puppet/puppetnet-loader/inputs/stitch_made_himself_pretty/stitch_made_himself_pretty.mp3")

    host = os.environ.get("PUPPETNET_IP", '192.168.4.1')
    port = 12345

    udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_sock.bind(('', port))

    sec_per_frame = 1 / fps
    next_frame = time.time()

    packet = {'dest': 'PUPPET_01', '_type': 'cmd', 'cmd': {'name': 'servo_0', 'state': None}}

    pygame.mixer.music.play()
    for pt in values:
        while True:
            if ((now := time.time()) < next_frame):
                time.sleep(next_frame - now + .0001)
                continue
            packet = {'dest': 'PUPPET_01', '_type': 'cmd', 'cmd': {'name': 'servo_0', 'state': pt}}
            command = json.dumps(packet)
            udp_sock.sendto(command.encode(), (host, port))
            next_frame = time.time() + sec_per_frame
            break

    return

class PlottedCurve:
    def __init__(self, x=None, y=None):
        self._x = np.array(x) if x is not None else np.array([])
        self._y = np.array(y) if y is not None else np.array([])

        self.undo_stack = []
        self.redo_stack = []

    @property
    def x(self):
        return self._x

    @x.setter
    def x(self, new_x):
        self._x = np.array(new_x)

    @property
    def y(self):
        return self._y

    @y.setter
    def y(self, new_y):
        self._y = np.array(new_y)

    def get_data(self):
        return self._x, self._y

    def set_data(self, x, y, record_undo=True):
        if record_undo:
            self.undo_stack.append((self._x.copy(), self._y.copy()))
            self.redo_stack.clear()
        self._x = np.array(x)
        self._y = np.array(y)

    def undo(self):
        print("Undo stack size:", len(self.undo_stack))
        print("Redo stack size:", len(self.redo_stack))

        if not self.undo_stack:
            return False
        self.redo_stack.append((self._x.copy(), self._y.copy()))
        self._x, self._y = self.undo_stack.pop()
        print("Undo stack size:", len(self.undo_stack))
        print("Redo stack size:", len(self.redo_stack))


        return True

    def redo(self):
        if not self.redo_stack:
            return False
        self.undo_stack.append((self._x.copy(), self._y.copy()))
        self._x, self._y = self.redo_stack.pop()
        return True



    def __len__(self):
        return len(self._x)


class MplGraphCanvas(FigureCanvas):
    def __init__(self, parent=None):
        self.mode = "click"
        self.shift_down = False
        self.ctrl_down = False
        self.meta_down = False
        self.alt_down = False


        self.fig = Figure()
        super().__init__(self.fig)
        self.ax = self.fig.add_subplot(111)

        self.ax.axhline(8000, color='lightgrey', linewidth=1, linestyle='--', zorder=0)
        self.ax.axhline(5000, color='lightgrey', linewidth=1, linestyle='--', zorder=0)

        self.curve = PlottedCurve(np.linspace(0, 10, 100), np.sin(np.linspace(0, 10, 100)))
        self.line, = self.ax.plot(self.curve.x, self.curve.y, color='dimgray', linestyle='-')

        self.last_drag_y = None
        self.setParent(parent)

        self.selected_indices = []
        self.last_selected_indices = []

        self.selector = RectangleSelector(
            self.ax,
            onselect=self.on_select,
            useblit=True,
            button=[1],
            minspanx=5, minspany=5,
            spancoords='pixels'
        )
        self.selector.set_active(False)

        self.control_indices = []
        self.control_scatter = self.ax.scatter([], [], color='red', zorder=5)
        self.set_draggable_points()

        self.dragging = None

        self.mpl_connect("button_press_event", self.on_click)
        self.mpl_connect("motion_notify_event", self.on_drag)
        self.mpl_connect("button_release_event", self.on_release)

        return


    def insert_point_at_start(self):
        # Get current curve data
        xx = [0] + [(n+1) for n in self.curve.x]
        yy = [self.curve.y[0]] + self.curve.y.tolist()

        # Set new data with undo recording
        self.curve.set_data(xx, yy, record_undo=True)
        self.control_indices = list(range(len(self.curve)))
        self.selected_indices = [0] + [(n+1) for n in self.selected_indices]

        self.update_curve()
        self.draw_idle()
        self.setFocus()
        self.update_view()
        return

    def update_view(self):
        self.ax.relim()
        self.ax.autoscale_view(scalex=True, scaley=False)
        self.ax.set_ylim(4000, 8300)
        return


    def key_press_event(self, event):
        if event.key() == Qt.Key_Shift:
            #print("Setting shift_down=True")
            self.shift_down = True
        if event.key() == Qt.Key_Control:
            #print("Setting control_down=True")
            self.control_down = True
        if event.key() == Qt.Key_Meta:
            #print("Setting meta_down=True")
            self.meta_down = True
        if event.key() == Qt.Key_Alt:
            #print("Setting alt_down=True")
            self.alt_down = True


        text = event.text().lower()

        print(text)

        if text == 's' and self.mode != "select":
            self.mode = "select"
            self.selector.set_active(True)
        elif text == 'q':
            if self.curve.undo():
                self.update_curve()
                self.draw_idle()
                self.setFocus()
                self.update_view()
        elif text == 'e':
            if self.curve.redo():
                self.update_curve()
                self.draw_idle()
                self.setFocus()
                self.update_view()
        elif text == 'x':
            if not self.selected_indices and self.last_selected_indices:
                self.selected_indices = self.last_selected_indices
            else:
                self.last_selected_indices = self.selected_indices
                self.selected_indices = []
            self.highlight_selected()
        elif text == 'i':
            self.insert_point_at_start()
        elif text == 'p':
            xx = self.curve.x.tolist()
            yy = self.curve.y.tolist()

            if self.shift_down:
                pass
            else:
                if not self.selected_indices:
                    pass
                else:
                    import IPython as ip, emacsipython as es; ip.embed(config=es.make_ipy_conf()) ## NJA-IPYTHO
            fps = 24
            play_on_puppet(xx, yy, fps)
        return

    def key_release_event(self, event):
        if event.key() == Qt.Key_Shift:
            #print("Setting shift_down=False")
            self.shift_down = False
        if event.key() == Qt.Key_Control:
            #print("Setting control_down=False")
            self.control_down = False
        if event.key() == Qt.Key_Meta:
            #print("Setting meta_down=False")
            self.meta_down = False
        if event.key() == Qt.Key_Alt:
            #print("Setting alt_down=False")
            self.alt_down = False

        text = event.text().lower()
        if text == 's' and self.mode == "select":
            self.mode = "click"
            self.selector.set_active(False)
        return


    def update_curve(self):
        self.line.set_data(self.curve.x, self.curve.y)
        self.ax.relim()
        self.ax.autoscale_view(scalex=True, scaley=False)
        self.ax.set_ylim(4000, 8000)
        self.update_control_display()
        self.draw_idle()


    def set_draggable_points(self):
        self.control_indices = list(range(len(self.curve)))
        self.control_scatter = self.ax.scatter(self.curve.x, self.curve.y, color='black', marker='x', zorder=5)
        return


    def on_select(self, eclick, erelease):
        if self.mode != "select":
            return

        x0, x1 = sorted([eclick.xdata, erelease.xdata])
        y0, y1 = sorted([eclick.ydata, erelease.ydata])


        if self.shift_down:
            for i in self.control_indices:
                x, y = self.curve.x[i], self.curve.y[i]
                if x0 <= x <= x1 and y0 <= y <= y1:
                    if i in self.selected_indices:
                        self.selected_indices.remove(i)
                    else:
                        self.selected_indices.append(i)
        else:
            self.selected_indices = []
            for i in self.control_indices:
                x, y = self.curve.x[i], self.curve.y[i]
                if x0 <= x <= x1 and y0 <= y <= y1:
                    self.selected_indices.append(i)

        self.highlight_selected()


    def highlight_selected(self):
        if not self.selected_indices:
            self.control_scatter.set_facecolors('black')
            self.draw_idle()
            return

        print(self.selected_indices)
        facecolors = ['green' if i in self.selected_indices else 'black' for i in self.control_indices]
        self.control_scatter.set_facecolors(facecolors)
        self.draw_idle()


    def on_click(self, event):
        if self.mode != "click" or event.inaxes != self.ax:
            return

        x_click = event.xdata
        idx = np.argmin(np.abs(self.curve.x - x_click))
        self.dragging = idx
        self.last_drag_y = event.ydata

        if self.shift_down:
            if idx in self.selected_indices:
                self.selected_indices.remove(idx)
            else:
                self.selected_indices.append(idx)
        else:
            # self.selected_indices = [idx]
            self.undo_pending = True  # record undo once on first drag

        self.highlight_selected()
        self.update_control_display()
        return

    def on_drag(self, event):
        if self.mode != "click" or self.dragging is None or event.inaxes != self.ax:
            return

        if event.ydata is None or self.last_drag_y is None:
            return

        dy = event.ydata - self.last_drag_y
        self.last_drag_y = event.ydata

        # Save current state for undo before applying changes
        if getattr(self, "undo_pending", True):
            self.curve.set_data(self.curve.x.copy(), self.curve.y.copy(), record_undo=True)
            self.undo_pending = False

        new_ys = self.curve.y.copy()
        if self.dragging in self.selected_indices:
            for i in self.selected_indices:
                new_y = new_ys[i] + dy
                if not (5000 <= new_y <= 8000):
                    return  # abort drag if any point goes out of bounds
                new_ys[i] = new_y
        else:
            new_y = event.ydata
            if not (5000 <= new_y <= 8000):
                return
            new_ys[self.dragging] = new_y

        self.curve.y = new_ys
        self.line.set_ydata(self.curve.y)
        self.update_control_display()
        self.draw_idle()
        return


    def on_release(self, event):
        if self.mode == "click":
            self.dragging = None
            self.last_drag_y = None

    def update_control_display(self):
        x_vals = [self.curve.x[i] for i in self.control_indices]
        y_vals = [self.curve.y[i] for i in self.control_indices]
        self.control_scatter.set_offsets(np.column_stack([x_vals, y_vals]))
        self.draw_idle()
        return

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Animation Adjustor")

        self.canvas = MplGraphCanvas(self)
        self.canvas.setFocusPolicy(Qt.StrongFocus)
        self.canvas.setFocus()

        self.canvas.keyPressEvent = self.canvas.key_press_event
        self.canvas.keyReleaseEvent = self.canvas.key_release_event

        self.save_button = QPushButton("Save")
        self.save_button.clicked.connect(self.save_to_csv)

        self.load_button = QPushButton("Load")
        self.load_button.clicked.connect(self.load_from_csv)

        layout = QVBoxLayout()
        layout.addWidget(self.canvas)

        self.toggle_button = QPushButton("Switch to Select Mode")
        self.toggle_button.clicked.connect(self.toggle_mode)

        layout.addWidget(self.toggle_button)

        layout.addWidget(self.load_button)
        layout.addWidget(self.save_button)

        container = QWidget()
        container.setLayout(layout)
        self.setCentralWidget(container)

        self.load_file("/Users/naddy/Source/Puppet/puppetnet-loader/inputs/stitch_made_himself_pretty/stitch_made_himself_pretty.json")

    def toggle_mode(self):
        if self.canvas.mode == "click":
            self.canvas.mode = "select"
            self.toggle_button.setText("Switch to Click Mode")
            self.canvas.selector.set_active(True)
        else:
            self.canvas.mode = "click"
            self.toggle_button.setText("Switch to Select Mode")
            self.canvas.selector.set_active(False)

    def save_to_csv(self):
        fname, _ = QFileDialog.getSaveFileName(self, "Save CSV", "", "CSV Files (*.csv)")
        if fname:
            np.savetxt(fname, np.column_stack([self.canvas.x, self.canvas.y]), delimiter=",")
            print(f"Saved to {fname}")

    def load_file(self, fname):
        data = json.loads(open(fname).read())
        servo_name = list(data["servos"].keys())[0]
        frames = [d['frame'] for d in data["history"]]
        values = [d["servos"][servo_name]["servo"] for d in data["history"]]

        self.canvas.curve.x = frames
        self.canvas.curve.y = values
        self.canvas.line.set_data(self.canvas.curve.x, self.canvas.curve.y)
        self.update_view()

        self.canvas.control_indices = []
        self.canvas.update_control_display()
        self.canvas.draw_idle()
        self.canvas.set_draggable_points()
        print(f"Loaded from {fname}")
        return

    def update_view(self):
        self.canvas.update_view()
        return

    def load_from_csv(self):
        fname, _ = QFileDialog.getOpenFileName(self, "Open CSV", "", "All Files (*)")
        if fname:
            self.load_file(fname)
            return

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.resize(1920, 1080)

    screens = app.screens()

    if len(screens) > 1:
        other_screen = screens[0]  # Index 0 is primary, 1 is usually the second screen
        geometry = other_screen.geometry()
        window.move(geometry.topLeft())

    window.show()
    sys.exit(app.exec())
